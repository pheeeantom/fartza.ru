import { createAction, createSlice, isAnyOf, isFulfilled, isRejectedWithValue, combineReducers } from '@reduxjs/toolkit';
import { QueryStatus } from './apiState.js';
import { calculateProvidedByThunk } from './buildThunks.js';
import { applyPatches } from 'immer';
import { onOnline, onOffline, onFocus, onFocusLost } from './setupListeners.js';
import { isOnline } from '../utils/isOnline.js';
import { isDocumentVisible } from '../utils/isDocumentVisible.js';
import { copyWithStructuralSharing } from '../utils/copyWithStructuralSharing.js';

function updateQuerySubstateIfExists(state, queryCacheKey, update) {
  const substate = state[queryCacheKey];

  if (substate) {
    update(substate);
  }
}

function updateMutationSubstateIfExists(state, {
  requestId
}, update) {
  const substate = state[requestId];

  if (substate) {
    update(substate);
  }
}

const initialState = {};
function buildSlice({
  reducerPath,
  queryThunk,
  mutationThunk,
  context: {
    endpointDefinitions: definitions
  },
  assertTagType,
  config
}) {
  const resetApiState = createAction(`${reducerPath}/resetApiState`);
  const querySlice = createSlice({
    name: `${reducerPath}/queries`,
    initialState: initialState,
    reducers: {
      removeQueryResult(draft, {
        payload: {
          queryCacheKey
        }
      }) {
        delete draft[queryCacheKey];
      },

      queryResultPatched(draft, {
        payload: {
          queryCacheKey,
          patches
        }
      }) {
        updateQuerySubstateIfExists(draft, queryCacheKey, substate => {
          substate.data = applyPatches(substate.data, patches);
        });
      }

    },

    extraReducers(builder) {
      builder.addCase(queryThunk.pending, (draft, {
        meta: {
          arg,
          requestId
        }
      }) => {
        if (arg.subscribe) {
          var _arg$queryCacheKey, _draft$_arg$queryCach;

          // only initialize substate if we want to subscribe to it
          (_draft$_arg$queryCach = draft[_arg$queryCacheKey = arg.queryCacheKey]) != null ? _draft$_arg$queryCach : draft[_arg$queryCacheKey] = {
            status: QueryStatus.uninitialized,
            endpointName: arg.endpointName
          };
        }

        updateQuerySubstateIfExists(draft, arg.queryCacheKey, substate => {
          substate.status = QueryStatus.pending;
          substate.requestId = requestId;
          substate.originalArgs = arg.originalArgs;
          substate.startedTimeStamp = arg.startedTimeStamp;
        });
      }).addCase(queryThunk.fulfilled, (draft, {
        meta,
        payload
      }) => {
        updateQuerySubstateIfExists(draft, meta.arg.queryCacheKey, substate => {
          if (substate.requestId !== meta.requestId) return;
          substate.status = QueryStatus.fulfilled;
          substate.data = copyWithStructuralSharing(substate.data, payload.result);
          delete substate.error;
          substate.fulfilledTimeStamp = payload.fulfilledTimeStamp;
        });
      }).addCase(queryThunk.rejected, (draft, {
        meta: {
          condition,
          arg,
          requestId
        },
        error,
        payload
      }) => {
        updateQuerySubstateIfExists(draft, arg.queryCacheKey, substate => {
          if (condition) ; else {
            // request failed
            if (substate.requestId !== requestId) return;
            substate.status = QueryStatus.rejected;
            substate.error = payload != null ? payload : error;
          }
        });
      });
    }

  });
  const mutationSlice = createSlice({
    name: `${reducerPath}/mutations`,
    initialState: initialState,
    reducers: {
      unsubscribeResult(draft, action) {
        if (action.payload.requestId in draft) {
          delete draft[action.payload.requestId];
        }
      }

    },

    extraReducers(builder) {
      builder.addCase(mutationThunk.pending, (draft, {
        meta: {
          arg,
          requestId
        }
      }) => {
        if (!arg.track) return;
        draft[requestId] = {
          status: QueryStatus.pending,
          originalArgs: arg.originalArgs,
          endpointName: arg.endpointName,
          startedTimeStamp: arg.startedTimeStamp
        };
      }).addCase(mutationThunk.fulfilled, (draft, {
        payload,
        meta: {
          requestId,
          arg
        }
      }) => {
        if (!arg.track) return;
        updateMutationSubstateIfExists(draft, {
          requestId
        }, substate => {
          substate.status = QueryStatus.fulfilled;
          substate.data = payload.result;
          substate.fulfilledTimeStamp = payload.fulfilledTimeStamp;
        });
      }).addCase(mutationThunk.rejected, (draft, {
        payload,
        error,
        meta: {
          requestId,
          arg
        }
      }) => {
        if (!arg.track) return;
        updateMutationSubstateIfExists(draft, {
          requestId
        }, substate => {
          substate.status = QueryStatus.rejected;
          substate.error = payload != null ? payload : error;
        });
      });
    }

  });
  const invalidationSlice = createSlice({
    name: `${reducerPath}/invalidation`,
    initialState: initialState,
    reducers: {},

    extraReducers(builder) {
      builder.addCase(querySlice.actions.removeQueryResult, (draft, {
        payload: {
          queryCacheKey
        }
      }) => {
        for (const tagTypeSubscriptions of Object.values(draft)) {
          for (const idSubscriptions of Object.values(tagTypeSubscriptions)) {
            const foundAt = idSubscriptions.indexOf(queryCacheKey);

            if (foundAt !== -1) {
              idSubscriptions.splice(foundAt, 1);
            }
          }
        }
      }).addMatcher(isAnyOf(isFulfilled(queryThunk), isRejectedWithValue(queryThunk)), (draft, action) => {
        const providedTags = calculateProvidedByThunk(action, 'providesTags', definitions, assertTagType);
        const {
          queryCacheKey
        } = action.meta.arg;

        for (const {
          type,
          id
        } of providedTags) {
          var _draft$type, _ref, _draft$type$_ref, _draft$type2;

          const subscribedQueries = (_draft$type$_ref = (_draft$type = (_draft$type2 = draft[type]) != null ? _draft$type2 : draft[type] = {})[_ref = id || '__internal_without_id']) != null ? _draft$type$_ref : _draft$type[_ref] = [];
          const alreadySubscribed = subscribedQueries.includes(queryCacheKey);

          if (!alreadySubscribed) {
            subscribedQueries.push(queryCacheKey);
          }
        }
      });
    }

  });
  const subscriptionSlice = createSlice({
    name: `${reducerPath}/subscriptions`,
    initialState: initialState,
    reducers: {
      updateSubscriptionOptions(draft, {
        payload: {
          queryCacheKey,
          requestId,
          options
        }
      }) {
        var _draft$queryCacheKey;

        if (draft != null && (_draft$queryCacheKey = draft[queryCacheKey]) != null && _draft$queryCacheKey[requestId]) {
          draft[queryCacheKey][requestId] = options;
        }
      },

      unsubscribeResult(draft, {
        payload: {
          queryCacheKey,
          requestId
        }
      }) {
        if (draft[queryCacheKey]) {
          delete draft[queryCacheKey][requestId];
        }
      }

    },
    extraReducers: builder => {
      builder.addCase(querySlice.actions.removeQueryResult, (draft, {
        payload: {
          queryCacheKey
        }
      }) => {
        delete draft[queryCacheKey];
      }).addCase(queryThunk.pending, (draft, {
        meta: {
          arg,
          requestId
        }
      }) => {
        if (arg.subscribe) {
          var _arg$queryCacheKey2, _draft$_arg$queryCach2, _ref2, _arg$subscriptionOpti;

          const substate = (_draft$_arg$queryCach2 = draft[_arg$queryCacheKey2 = arg.queryCacheKey]) != null ? _draft$_arg$queryCach2 : draft[_arg$queryCacheKey2] = {};
          substate[requestId] = (_ref2 = (_arg$subscriptionOpti = arg.subscriptionOptions) != null ? _arg$subscriptionOpti : substate[requestId]) != null ? _ref2 : {};
        }
      }).addCase(queryThunk.rejected, (draft, {
        meta: {
          condition,
          arg,
          requestId
        },
        error,
        payload
      }) => {
        const substate = draft[arg.queryCacheKey]; // request was aborted due to condition (another query already running)

        if (condition && arg.subscribe && substate) {
          var _ref3, _arg$subscriptionOpti2;

          substate[requestId] = (_ref3 = (_arg$subscriptionOpti2 = arg.subscriptionOptions) != null ? _arg$subscriptionOpti2 : substate[requestId]) != null ? _ref3 : {};
        }
      });
    }
  });
  const configSlice = createSlice({
    name: `${reducerPath}/config`,
    initialState: {
      online: isOnline(),
      focused: isDocumentVisible(),
      ...config
    },
    reducers: {},
    extraReducers: builder => {
      builder.addCase(onOnline, state => {
        state.online = true;
      }).addCase(onOffline, state => {
        state.online = false;
      }).addCase(onFocus, state => {
        state.focused = true;
      }).addCase(onFocusLost, state => {
        state.focused = false;
      });
    }
  });
  const combinedReducer = combineReducers({
    queries: querySlice.reducer,
    mutations: mutationSlice.reducer,
    provided: invalidationSlice.reducer,
    subscriptions: subscriptionSlice.reducer,
    config: configSlice.reducer
  });

  const reducer = (state, action) => combinedReducer(resetApiState.match(action) ? undefined : state, action);

  const actions = {
    updateSubscriptionOptions: subscriptionSlice.actions.updateSubscriptionOptions,
    queryResultPatched: querySlice.actions.queryResultPatched,
    removeQueryResult: querySlice.actions.removeQueryResult,
    unsubscribeQueryResult: subscriptionSlice.actions.unsubscribeResult,
    unsubscribeMutationResult: mutationSlice.actions.unsubscribeResult,
    resetApiState
  };
  return {
    reducer,
    actions
  };
}

export { buildSlice };
//# sourceMappingURL=buildSlice.js.map
