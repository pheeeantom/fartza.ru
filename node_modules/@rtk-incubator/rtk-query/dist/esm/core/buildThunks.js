import { QueryStatus } from './apiState.js';
import { calculateProvidedBy } from '../endpointDefinitions.js';
import { createAsyncThunk, isAllOf, isPending, isFulfilled, isRejected, isRejectedWithValue } from '@reduxjs/toolkit';
import { isDraftable, enablePatches, produceWithPatches } from 'immer';
import { HandledError } from '../HandledError.js';

function defaultTransformResponse(baseQueryReturnValue) {
  return baseQueryReturnValue;
}

function buildThunks({
  reducerPath,
  baseQuery,
  context: {
    endpointDefinitions
  },
  serializeQueryArgs,
  api
}) {
  const patchQueryResult = (endpointName, args, patches) => dispatch => {
    const endpointDefinition = endpointDefinitions[endpointName];
    dispatch(api.internalActions.queryResultPatched({
      queryCacheKey: serializeQueryArgs({
        queryArgs: args,
        endpointDefinition,
        endpointName
      }),
      patches
    }));
  };

  const updateQueryResult = (endpointName, args, updateRecipe) => (dispatch, getState) => {
    const currentState = api.endpoints[endpointName].select(args)(getState());
    let ret = {
      patches: [],
      inversePatches: []
    };

    if (currentState.status === QueryStatus.uninitialized) {
      return ret;
    }

    if ('data' in currentState) {
      if (isDraftable(currentState.data)) {
        // call "enablePatches" as late as possible
        enablePatches();
        const [, patches, inversePatches] = produceWithPatches(currentState.data, updateRecipe);
        ret.patches.push(...patches);
        ret.inversePatches.push(...inversePatches);
      } else {
        const value = updateRecipe(currentState.data);
        ret.patches.push({
          op: 'replace',
          path: [],
          value
        });
        ret.inversePatches.push({
          op: 'replace',
          path: [],
          value: currentState.data
        });
      }
    }

    dispatch(patchQueryResult(endpointName, args, ret.patches));
    return ret;
  };

  const executeEndpoint = async (arg, {
    signal,
    rejectWithValue,
    ...api
  }) => {
    const endpointDefinition = endpointDefinitions[arg.endpointName];
    const context = {};
    const queryApi = { ...api,
      context
    };
    if (endpointDefinition.onStart) endpointDefinition.onStart(arg.originalArgs, queryApi);

    try {
      let transformResponse = defaultTransformResponse;
      let result;
      const baseQueryApi = {
        signal,
        dispatch: api.dispatch,
        getState: api.getState
      };

      if (endpointDefinition.query) {
        result = await baseQuery(endpointDefinition.query(arg.originalArgs), baseQueryApi, endpointDefinition.extraOptions);

        if (endpointDefinition.transformResponse) {
          transformResponse = endpointDefinition.transformResponse;
        }
      } else {
        result = await endpointDefinition.queryFn(arg.originalArgs, baseQueryApi, endpointDefinition.extraOptions, arg => baseQuery(arg, baseQueryApi, endpointDefinition.extraOptions));
      }

      if (result.error) throw new HandledError(result.error, result.meta);
      if (endpointDefinition.onSuccess) endpointDefinition.onSuccess(arg.originalArgs, queryApi, result.data, result.meta);
      return {
        fulfilledTimeStamp: Date.now(),
        result: await transformResponse(result.data, result.meta)
      };
    } catch (error) {
      if (endpointDefinition.onError) endpointDefinition.onError(arg.originalArgs, queryApi, error instanceof HandledError ? error.value : error, error instanceof HandledError ? error.meta : undefined);

      if (error instanceof HandledError) {
        return rejectWithValue(error.value);
      }

      throw error;
    }
  };

  const queryThunk = createAsyncThunk(`${reducerPath}/executeQuery`, executeEndpoint, {
    condition(arg, {
      getState
    }) {
      var _state$queries, _arg$forceRefetch;

      const state = getState()[reducerPath];
      const requestState = state == null ? void 0 : (_state$queries = state.queries) == null ? void 0 : _state$queries[arg.queryCacheKey];
      const baseFetchOnMountOrArgChange = state.config.refetchOnMountOrArgChange;
      const fulfilledVal = requestState == null ? void 0 : requestState.fulfilledTimeStamp;
      const refetchVal = (_arg$forceRefetch = arg.forceRefetch) != null ? _arg$forceRefetch : arg.subscribe && baseFetchOnMountOrArgChange; // Don't retry a request that's currently in-flight

      if ((requestState == null ? void 0 : requestState.status) === 'pending') return false; // Pull from the cache unless we explicitly force refetch or qualify based on time

      if (fulfilledVal) {
        if (refetchVal) {
          // Return if its true or compare the dates because it must be a number
          return refetchVal === true || (Number(new Date()) - Number(fulfilledVal)) / 1000 >= refetchVal;
        } // Value is cached and we didn't specify to refresh, skip it.


        return false;
      }

      return true;
    },

    dispatchConditionRejection: true
  });
  const mutationThunk = createAsyncThunk(`${reducerPath}/executeMutation`, executeEndpoint);

  const hasTheForce = options => 'force' in options;

  const hasMaxAge = options => 'ifOlderThan' in options;

  const prefetch = (endpointName, arg, options) => (dispatch, getState) => {
    const force = hasTheForce(options) && options.force;
    const maxAge = hasMaxAge(options) && options.ifOlderThan;

    const queryAction = (force = true) => api.endpoints[endpointName].initiate(arg, {
      forceRefetch: force
    });

    const latestStateValue = api.endpoints[endpointName].select(arg)(getState());

    if (force) {
      dispatch(queryAction());
    } else if (maxAge) {
      const lastFulfilledTs = latestStateValue == null ? void 0 : latestStateValue.fulfilledTimeStamp;

      if (!lastFulfilledTs) {
        dispatch(queryAction());
        return;
      }

      const shouldRetrigger = (Number(new Date()) - Number(new Date(lastFulfilledTs))) / 1000 >= maxAge;

      if (shouldRetrigger) {
        dispatch(queryAction());
      }
    } else {
      // If prefetching with no options, just let it try
      dispatch(queryAction(false));
    }
  };

  function matchesEndpoint(endpointName) {
    return action => {
      var _action$meta, _action$meta$arg;

      return (action == null ? void 0 : (_action$meta = action.meta) == null ? void 0 : (_action$meta$arg = _action$meta.arg) == null ? void 0 : _action$meta$arg.endpointName) === endpointName;
    };
  }

  function buildMatchThunkActions(thunk, endpointName) {
    return {
      matchPending: isAllOf(isPending(thunk), matchesEndpoint(endpointName)),
      matchFulfilled: isAllOf(isFulfilled(thunk), matchesEndpoint(endpointName)),
      matchRejected: isAllOf(isRejected(thunk), matchesEndpoint(endpointName))
    };
  }

  return {
    queryThunk,
    mutationThunk,
    prefetch,
    updateQueryResult,
    patchQueryResult,
    buildMatchThunkActions
  };
}
function calculateProvidedByThunk(action, type, endpointDefinitions, assertTagType) {
  return calculateProvidedBy(endpointDefinitions[action.meta.arg.endpointName][type], isFulfilled(action) ? action.payload.result : undefined, isRejectedWithValue(action) ? action.payload : undefined, action.meta.arg.originalArgs, assertTagType);
}

export { buildThunks, calculateProvidedByThunk };
//# sourceMappingURL=buildThunks.js.map
