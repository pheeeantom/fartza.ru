import { createAction, isAnyOf, isFulfilled, isRejectedWithValue } from '@reduxjs/toolkit';
import { QueryStatus } from './apiState.js';
import { calculateProvidedByThunk } from './buildThunks.js';
import { calculateProvidedBy } from '../endpointDefinitions.js';
import { onFocus, onOnline } from './setupListeners.js';
import { flatten } from '../utils/flatten.js';

function buildMiddleware({
  reducerPath,
  context,
  context: {
    endpointDefinitions
  },
  queryThunk,
  mutationThunk,
  api,
  assertTagType
}) {
  const {
    removeQueryResult,
    unsubscribeQueryResult,
    updateSubscriptionOptions,
    resetApiState
  } = api.internalActions;
  const currentRemovalTimeouts = {};
  const currentPolls = {};
  const actions = {
    invalidateTags: createAction(`${reducerPath}/invalidateTags`)
  };

  const middleware = mwApi => next => action => {
    const result = next(action);

    if (isAnyOf(isFulfilled(mutationThunk), isRejectedWithValue(mutationThunk))(action)) {
      invalidateTags(calculateProvidedByThunk(action, 'invalidatesTags', endpointDefinitions, assertTagType), mwApi);
    }

    if (actions.invalidateTags.match(action)) {
      invalidateTags(calculateProvidedBy(action.payload, undefined, undefined, undefined, assertTagType), mwApi);
    }

    if (unsubscribeQueryResult.match(action)) {
      handleUnsubscribe(action.payload, mwApi);
    }

    if (updateSubscriptionOptions.match(action)) {
      updatePollingInterval(action.payload, mwApi);
    }

    if (queryThunk.pending.match(action) || queryThunk.rejected.match(action) && action.meta.condition) {
      updatePollingInterval(action.meta.arg, mwApi);
    }

    if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action) && !action.meta.condition) {
      startNextPoll(action.meta.arg, mwApi);
    }

    if (onFocus.match(action)) {
      refetchValidQueries(mwApi, 'refetchOnFocus');
    }

    if (onOnline.match(action)) {
      refetchValidQueries(mwApi, 'refetchOnReconnect');
    }

    if (resetApiState.match(action)) {
      for (const [key, poll] of Object.entries(currentPolls)) {
        if (poll != null && poll.timeout) clearTimeout(poll.timeout);
        delete currentPolls[key];
      }

      for (const [key, timeout] of Object.entries(currentRemovalTimeouts)) {
        if (timeout) clearTimeout(timeout);
        delete currentRemovalTimeouts[key];
      }
    }

    return result;
  };

  return {
    middleware,
    actions
  };

  function refetchQuery(querySubState, queryCacheKey, override = {}) {
    return queryThunk({
      endpointName: querySubState.endpointName,
      originalArgs: querySubState.originalArgs,
      subscribe: false,
      forceRefetch: true,
      startedTimeStamp: Date.now(),
      queryCacheKey: queryCacheKey,
      ...override
    });
  }

  function refetchValidQueries(api, type) {
    const state = api.getState()[reducerPath];
    const queries = state.queries;
    const subscriptions = state.subscriptions;
    context.batch(() => {
      for (const queryCacheKey of Object.keys(subscriptions)) {
        const querySubState = queries[queryCacheKey];
        const subscriptionSubState = subscriptions[queryCacheKey];
        if (!subscriptionSubState || !querySubState || querySubState.status === QueryStatus.uninitialized) return;
        const shouldRefetch = Object.values(subscriptionSubState).some(sub => sub[type] === true) || Object.values(subscriptionSubState).every(sub => sub[type] === undefined) && state.config[type];

        if (shouldRefetch) {
          api.dispatch(refetchQuery(querySubState, queryCacheKey));
        }
      }
    });
  }

  function invalidateTags(tags, api) {
    const state = api.getState()[reducerPath];
    const toInvalidate = new Set();

    for (const tag of tags) {
      var _ref;

      const provided = state.provided[tag.type];

      if (!provided) {
        continue;
      }

      let invalidateSubscriptions = (_ref = tag.id !== undefined ? // id given: invalidate all queries that provide this type & id
      provided[tag.id] : // no id: invalidate all queries that provide this type
      flatten(Object.values(provided))) != null ? _ref : [];

      for (const invalidate of invalidateSubscriptions) {
        toInvalidate.add(invalidate);
      }
    }

    context.batch(() => {
      for (const queryCacheKey of toInvalidate.values()) {
        const querySubState = state.queries[queryCacheKey];
        const subscriptionSubState = state.subscriptions[queryCacheKey];

        if (querySubState && subscriptionSubState) {
          if (Object.keys(subscriptionSubState).length === 0) {
            api.dispatch(removeQueryResult({
              queryCacheKey
            }));
          } else if (querySubState.status !== QueryStatus.uninitialized) {
            api.dispatch(refetchQuery(querySubState, queryCacheKey));
          } else ;
        }
      }
    });
  }

  function handleUnsubscribe({
    queryCacheKey
  }, api) {
    const keepUnusedDataFor = api.getState()[reducerPath].config.keepUnusedDataFor;
    const currentTimeout = currentRemovalTimeouts[queryCacheKey];

    if (currentTimeout) {
      clearTimeout(currentTimeout);
    }

    currentRemovalTimeouts[queryCacheKey] = setTimeout(() => {
      const subscriptions = api.getState()[reducerPath].subscriptions[queryCacheKey];

      if (!subscriptions || Object.keys(subscriptions).length === 0) {
        api.dispatch(removeQueryResult({
          queryCacheKey
        }));
      }

      delete currentRemovalTimeouts[queryCacheKey];
    }, keepUnusedDataFor * 1000);
  }

  function startNextPoll({
    queryCacheKey
  }, api) {
    const state = api.getState()[reducerPath];
    const querySubState = state.queries[queryCacheKey];
    const subscriptions = state.subscriptions[queryCacheKey];
    if (!querySubState || querySubState.status === QueryStatus.uninitialized) return;
    const lowestPollingInterval = findLowestPollingInterval(subscriptions);
    if (!Number.isFinite(lowestPollingInterval)) return;
    const currentPoll = currentPolls[queryCacheKey];

    if (currentPoll != null && currentPoll.timeout) {
      clearTimeout(currentPoll.timeout);
      currentPoll.timeout = undefined;
    }

    const nextPollTimestamp = Date.now() + lowestPollingInterval;
    const currentInterval = currentPolls[queryCacheKey] = {
      nextPollTimestamp,
      pollingInterval: lowestPollingInterval,
      timeout: setTimeout(() => {
        currentInterval.timeout = undefined;
        api.dispatch(refetchQuery(querySubState, queryCacheKey));
      }, lowestPollingInterval)
    };
  }

  function updatePollingInterval({
    queryCacheKey
  }, api) {
    const state = api.getState()[reducerPath];
    const querySubState = state.queries[queryCacheKey];
    const subscriptions = state.subscriptions[queryCacheKey];

    if (!querySubState || querySubState.status === QueryStatus.uninitialized) {
      return;
    }

    const lowestPollingInterval = findLowestPollingInterval(subscriptions);
    const currentPoll = currentPolls[queryCacheKey];

    if (!Number.isFinite(lowestPollingInterval)) {
      if (currentPoll != null && currentPoll.timeout) {
        clearTimeout(currentPoll.timeout);
      }

      delete currentPolls[queryCacheKey];
      return;
    }

    const nextPollTimestamp = Date.now() + lowestPollingInterval;

    if (!currentPoll || nextPollTimestamp < currentPoll.nextPollTimestamp) {
      startNextPoll({
        queryCacheKey
      }, api);
    }
  }
}

function findLowestPollingInterval(subscribers = {}) {
  let lowestPollingInterval = Number.POSITIVE_INFINITY;

  for (const subscription of Object.values(subscribers)) {
    if (!!subscription.pollingInterval) lowestPollingInterval = Math.min(subscription.pollingInterval, lowestPollingInterval);
  }

  return lowestPollingInterval;
}

export { buildMiddleware };
//# sourceMappingURL=buildMiddleware.js.map
