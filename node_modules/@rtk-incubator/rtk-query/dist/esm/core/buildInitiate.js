import { unwrapResult } from '@reduxjs/toolkit';

function buildInitiate({
  serializeQueryArgs,
  queryThunk,
  mutationThunk,
  api
}) {
  const {
    unsubscribeQueryResult,
    unsubscribeMutationResult,
    updateSubscriptionOptions
  } = api.internalActions;
  return {
    buildInitiateQuery,
    buildInitiateMutation
  };

  function buildInitiateQuery(endpointName, endpointDefinition) {
    const queryAction = (arg, {
      subscribe = true,
      forceRefetch,
      subscriptionOptions
    } = {}) => (dispatch, getState) => {
      const queryCacheKey = serializeQueryArgs({
        queryArgs: arg,
        endpointDefinition,
        endpointName
      });
      const thunk = queryThunk({
        subscribe,
        forceRefetch,
        subscriptionOptions,
        endpointName,
        originalArgs: arg,
        queryCacheKey,
        startedTimeStamp: Date.now()
      });
      const thunkResult = dispatch(thunk);
      const {
        requestId,
        abort
      } = thunkResult;
      const statePromise = Object.assign(thunkResult.then(() => api.endpoints[endpointName].select(arg)(getState())), {
        arg,
        requestId,
        subscriptionOptions,
        abort,

        refetch() {
          dispatch(queryAction(arg, {
            subscribe: false,
            forceRefetch: true
          }));
        },

        unsubscribe() {
          if (subscribe) dispatch(unsubscribeQueryResult({
            queryCacheKey,
            requestId
          }));
        },

        updateSubscriptionOptions(options) {
          statePromise.subscriptionOptions = options;
          dispatch(updateSubscriptionOptions({
            endpointName,
            requestId,
            queryCacheKey,
            options
          }));
        }

      });
      return statePromise;
    };

    return queryAction;
  }

  function buildInitiateMutation(endpointName, definition) {
    return (arg, {
      track = true
    } = {}) => (dispatch, getState) => {
      const thunk = mutationThunk({
        endpointName,
        originalArgs: arg,
        track,
        startedTimeStamp: Date.now()
      });
      const thunkResult = dispatch(thunk);
      const {
        requestId,
        abort
      } = thunkResult;
      const returnValuePromise = thunkResult.then(unwrapResult).then(unwrapped => ({
        data: unwrapped.result
      })).catch(error => ({
        error
      }));
      return Object.assign(returnValuePromise, {
        arg: thunkResult.arg,
        requestId,
        abort,

        unwrap() {
          return thunkResult.then(unwrapResult).then(unwrapped => unwrapped.result);
        },

        unsubscribe() {
          if (track) dispatch(unsubscribeMutationResult({
            requestId
          }));
        }

      });
    };
  }
}

export { buildInitiate };
//# sourceMappingURL=buildInitiate.js.map
