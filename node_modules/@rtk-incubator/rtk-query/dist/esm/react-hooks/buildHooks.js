import { createSelector } from '@reduxjs/toolkit';
import { useCallback, useMemo, useState, useRef, useEffect } from 'react';
import { QueryStatus } from '../core/apiState.js';
import { skipSelector } from '../core/buildSelectors.js';
import { useShallowStableValue } from './useShallowStableValue.js';
import { UNINITIALIZED_VALUE } from '../constants.js';
import { shallowEqual } from '../utils/shallowEqual.js';

const defaultMutationStateSelector = currentState => currentState;

const defaultQueryStateSelector = (currentState, lastResult) => {
  var _ref;

  // data is the last known good request result we have tracked - or if none has been tracked yet the last good result for the current args
  const data = (_ref = currentState.isSuccess ? currentState.data : lastResult == null ? void 0 : lastResult.data) != null ? _ref : currentState.data; // isFetching = true any time a request is in flight

  const isFetching = currentState.isLoading; // isLoading = true only when loading while no data is present yet (initial load with no data in the cache)

  const isLoading = !data && isFetching; // isSuccess = true when data is present

  const isSuccess = currentState.isSuccess || isFetching && !!data;
  return { ...currentState,
    data,
    isFetching,
    isLoading,
    isSuccess
  };
};
/**
 * Wrapper around `defaultQueryStateSelector` to be used in `useQuery`.
 * We want the initial render to already come back with
 * `{ isUninitialized: false, isFetching: true, isLoading: true }`
 * to prevent that the library user has to do an additional check for `isUninitialized`/
 */


const noPendingQueryStateSelector = (currentState, lastResult) => {
  const selected = defaultQueryStateSelector(currentState, lastResult);

  if (selected.isUninitialized) {
    return { ...selected,
      isUninitialized: false,
      isFetching: true,
      isLoading: true,
      status: QueryStatus.pending
    };
  }

  return selected;
};
/**
 *
 * @param opts.api - An API with defined endpoints to create hooks for
 * @param opts.moduleOptions.batch - The version of the `batchedUpdates` function to be used
 * @param opts.moduleOptions.useDispatch - The version of the `useDispatch` hook to be used
 * @param opts.moduleOptions.useSelector - The version of the `useSelector` hook to be used
 * @returns An object containing functions to generate hooks based on an endpoint
 */


function buildHooks({
  api,
  moduleOptions: {
    batch,
    useDispatch,
    useSelector
  }
}) {
  return {
    buildQueryHooks,
    buildMutationHook,
    usePrefetch
  };

  function usePrefetch(endpointName, defaultOptions) {
    const dispatch = useDispatch();
    const stableDefaultOptions = useShallowStableValue(defaultOptions);
    return useCallback((arg, options) => dispatch(api.util.prefetch(endpointName, arg, { ...stableDefaultOptions,
      ...options
    })), [endpointName, dispatch, stableDefaultOptions]);
  }

  function buildQueryHooks(name) {
    const useQuerySubscription = (arg, {
      refetchOnReconnect,
      refetchOnFocus,
      refetchOnMountOrArgChange,
      skip = false,
      pollingInterval = 0
    } = {}) => {
      const {
        initiate
      } = api.endpoints[name];
      const dispatch = useDispatch();
      const stableArg = useShallowStableValue(arg);
      const stableSubscriptionOptions = useShallowStableValue({
        refetchOnReconnect,
        refetchOnFocus,
        pollingInterval
      });
      const promiseRef = useRef();
      useEffect(() => {
        var _promiseRef$current;

        if (skip) {
          return;
        }

        const lastPromise = promiseRef.current;
        const lastSubscriptionOptions = (_promiseRef$current = promiseRef.current) == null ? void 0 : _promiseRef$current.subscriptionOptions;

        if (!lastPromise || lastPromise.arg !== stableArg) {
          lastPromise == null ? void 0 : lastPromise.unsubscribe();
          const promise = dispatch(initiate(stableArg, {
            subscriptionOptions: stableSubscriptionOptions,
            forceRefetch: refetchOnMountOrArgChange
          }));
          promiseRef.current = promise;
        } else if (stableSubscriptionOptions !== lastSubscriptionOptions) {
          lastPromise.updateSubscriptionOptions(stableSubscriptionOptions);
        }
      }, [dispatch, initiate, refetchOnMountOrArgChange, skip, stableArg, stableSubscriptionOptions]);
      useEffect(() => {
        return () => {
          var _promiseRef$current2;

          (_promiseRef$current2 = promiseRef.current) == null ? void 0 : _promiseRef$current2.unsubscribe();
          promiseRef.current = undefined;
        };
      }, []);
      return useMemo(() => ({
        /**
         * A method to manually refetch data for the query
         */
        refetch: () => {
          var _promiseRef$current3;

          return void ((_promiseRef$current3 = promiseRef.current) == null ? void 0 : _promiseRef$current3.refetch());
        }
      }), []);
    };

    const useLazyQuerySubscription = ({
      refetchOnReconnect,
      refetchOnFocus,
      pollingInterval = 0
    } = {}) => {
      const {
        initiate
      } = api.endpoints[name];
      const dispatch = useDispatch();
      const [arg, setArg] = useState(UNINITIALIZED_VALUE);
      const promiseRef = useRef();
      const stableSubscriptionOptions = useShallowStableValue({
        refetchOnReconnect,
        refetchOnFocus,
        pollingInterval
      });
      useEffect(() => {
        var _promiseRef$current4;

        const lastSubscriptionOptions = (_promiseRef$current4 = promiseRef.current) == null ? void 0 : _promiseRef$current4.subscriptionOptions;

        if (stableSubscriptionOptions !== lastSubscriptionOptions) {
          var _promiseRef$current5;

          (_promiseRef$current5 = promiseRef.current) == null ? void 0 : _promiseRef$current5.updateSubscriptionOptions(stableSubscriptionOptions);
        }
      }, [stableSubscriptionOptions]);
      const subscriptionOptionsRef = useRef(stableSubscriptionOptions);
      useEffect(() => {
        subscriptionOptionsRef.current = stableSubscriptionOptions;
      }, [stableSubscriptionOptions]);
      const trigger = useCallback(function (arg, preferCacheValue = false) {
        batch(() => {
          var _promiseRef$current6;

          (_promiseRef$current6 = promiseRef.current) == null ? void 0 : _promiseRef$current6.unsubscribe();
          promiseRef.current = dispatch(initiate(arg, {
            subscriptionOptions: subscriptionOptionsRef.current,
            forceRefetch: !preferCacheValue
          }));
          setArg(arg);
        });
      }, [dispatch, initiate]);
      /* cleanup on unmount */

      useEffect(() => {
        return () => {
          var _promiseRef$current7;

          promiseRef == null ? void 0 : (_promiseRef$current7 = promiseRef.current) == null ? void 0 : _promiseRef$current7.unsubscribe();
        };
      }, []);
      /* if "cleanup on unmount" was triggered from a fast refresh, we want to reinstate the query */

      useEffect(() => {
        if (arg !== UNINITIALIZED_VALUE && !promiseRef.current) {
          trigger(arg, true);
        }
      }, [arg, trigger]);
      return useMemo(() => [trigger, arg], [trigger, arg]);
    };

    const useQueryState = (arg, {
      skip = false,
      selectFromResult = defaultQueryStateSelector
    } = {}) => {
      const {
        select
      } = api.endpoints[name];
      const stableArg = useShallowStableValue(arg);
      const lastValue = useRef();
      const querySelector = useMemo(() => createSelector([select(skip ? skipSelector : stableArg), (_, lastResult) => lastResult], (subState, lastResult) => selectFromResult(subState, lastResult, defaultQueryStateSelector)), [select, skip, stableArg, selectFromResult]);
      const currentState = useSelector(state => querySelector(state, lastValue.current), shallowEqual);
      useEffect(() => {
        lastValue.current = currentState;
      }, [currentState]);
      return currentState;
    };

    return {
      useQueryState,
      useQuerySubscription,
      useLazyQuerySubscription,

      useLazyQuery(options) {
        const [trigger, arg] = useLazyQuerySubscription(options);
        const queryStateResults = useQueryState(arg, { ...options,
          skip: arg === UNINITIALIZED_VALUE
        });
        const info = useMemo(() => ({
          lastArg: arg
        }), [arg]);
        return useMemo(() => [trigger, queryStateResults, info], [trigger, queryStateResults, info]);
      },

      useQuery(arg, options) {
        const querySubscriptionResults = useQuerySubscription(arg, options);
        const queryStateResults = useQueryState(arg, {
          selectFromResult: options != null && options.skip ? undefined : noPendingQueryStateSelector,
          ...options
        });
        return useMemo(() => ({ ...queryStateResults,
          ...querySubscriptionResults
        }), [queryStateResults, querySubscriptionResults]);
      }

    };
  }

  function buildMutationHook(name) {
    return ({
      selectFromResult = defaultMutationStateSelector
    } = {}) => {
      const {
        select,
        initiate
      } = api.endpoints[name];
      const dispatch = useDispatch();
      const [requestId, setRequestId] = useState();
      const promiseRef = useRef();
      useEffect(() => {
        return () => {
          var _promiseRef$current8;

          (_promiseRef$current8 = promiseRef.current) == null ? void 0 : _promiseRef$current8.unsubscribe();
          promiseRef.current = undefined;
        };
      }, []);
      const triggerMutation = useCallback(function (arg) {
        let promise;
        batch(() => {
          var _promiseRef$current9;

          promiseRef == null ? void 0 : (_promiseRef$current9 = promiseRef.current) == null ? void 0 : _promiseRef$current9.unsubscribe();
          promise = dispatch(initiate(arg));
          promiseRef.current = promise;
          setRequestId(promise.requestId);
        });
        return promise;
      }, [dispatch, initiate]);
      const mutationSelector = useMemo(() => createSelector([select(requestId || skipSelector)], subState => selectFromResult(subState, defaultMutationStateSelector)), [select, requestId, selectFromResult]);
      const currentState = useSelector(mutationSelector, shallowEqual);
      return useMemo(() => [triggerMutation, currentState], [triggerMutation, currentState]);
    };
  }
}

export { buildHooks };
//# sourceMappingURL=buildHooks.js.map
