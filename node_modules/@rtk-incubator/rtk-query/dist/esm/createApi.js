import { defaultSerializeQueryArgs } from './defaultSerializeQueryArgs.js';
import { DefinitionType } from './endpointDefinitions.js';

/**
 * Builds a `createApi` method based on the provided `modules`.
 *
 * @link https://rtk-query-docs.netlify.app/concepts/customizing-create-api
 *
 * @example
 * ```ts
 * const MyContext = React.createContext<ReactReduxContextValue>(null as any);
 * const customCreateApi = buildCreateApi(
 *   coreModule(),
 *   reactHooksModule({ useDispatch: createDispatchHook(MyContext) })
 * );
 * ```
 *
 * @param modules - A variable number of modules that customize how the `createApi` method handles endpoints
 * @returns A `createApi` method using the provided `modules`.
 */

function buildCreateApi(...modules) {
  return function baseCreateApi(options) {
    // remove in final release
    if (options.entityTypes) {
      var _options$tagTypes;

      if (typeof process !== 'undefined' && process.env.NODE_ENV === 'development') {
        console.warn('`entityTypes` has been renamed to `tagTypes`, please change your code accordingly');
      }

      (_options$tagTypes = options.tagTypes) != null ? _options$tagTypes : options.tagTypes = options.entityTypes;
    }

    const optionsWithDefaults = {
      reducerPath: 'api',
      serializeQueryArgs: defaultSerializeQueryArgs,
      keepUnusedDataFor: 60,
      refetchOnMountOrArgChange: false,
      refetchOnFocus: false,
      refetchOnReconnect: false,
      ...options,
      entityTypes: [],
      tagTypes: [...(options.tagTypes || [])]
    };
    const context = {
      endpointDefinitions: {},

      batch(fn) {
        // placeholder "batch" method to be overridden by plugins, for example with React.unstable_batchedUpdate
        fn();
      }

    };
    const api = {
      injectEndpoints,

      enhanceEndpoints({
        addTagTypes,
        endpoints,
        addEntityTypes
      }) {
        // remove in final release
        if (addEntityTypes) {
          var _addTagTypes;

          if (typeof process !== 'undefined' && process.env.NODE_ENV === 'development') {
            console.warn('`addEntityTypes` has been renamed to `addTagTypes`, please change your code accordingly');
          }

          (_addTagTypes = addTagTypes) != null ? _addTagTypes : addTagTypes = addEntityTypes;
        }

        if (addTagTypes) {
          for (const eT of addTagTypes) {
            if (!optionsWithDefaults.tagTypes.includes(eT)) {
              optionsWithDefaults.tagTypes.push(eT);
            }
          }
        }

        if (endpoints) {
          for (const [endpointName, partialDefinition] of Object.entries(endpoints)) {
            if (typeof partialDefinition === 'function') {
              partialDefinition(context.endpointDefinitions[endpointName]);
            }

            Object.assign(context.endpointDefinitions[endpointName] || {}, partialDefinition); // remove in final release

            const x = context.endpointDefinitions[endpointName];

            if (x != null && x.provides) {
              if (typeof process !== 'undefined' && process.env.NODE_ENV === 'development') {
                console.warn('`provides` has been renamed to `providesTags`, please change your code accordingly');
              }

              x.providesTags = x.provides;
            }

            if (x != null && x.invalidates) {
              if (typeof process !== 'undefined' && process.env.NODE_ENV === 'development') {
                console.warn('`invalidates` has been renamed to `invalidatesTags`, please change your code accordingly');
              }

              x.invalidatesTags = x.invalidates;
            }
          }
        }

        return api;
      }

    };
    const initializedModules = modules.map(m => m.init(api, optionsWithDefaults, context));

    function injectEndpoints(inject) {
      const evaluatedEndpoints = inject.endpoints({
        query: x => {
          // remove in final release
          if (x.provides) {
            var _x$providesTags;

            if (typeof process !== 'undefined' && process.env.NODE_ENV === 'development') {
              console.warn('`provides` has been renamed to `providesTags`, please change your code accordingly');
            }

            (_x$providesTags = x.providesTags) != null ? _x$providesTags : x.providesTags = x.provides;
          }

          return { ...x,
            type: DefinitionType.query
          };
        },
        mutation: x => {
          // remove in final release
          if (x.invalidates) {
            var _x$invalidatesTags;

            if (typeof process !== 'undefined' && process.env.NODE_ENV === 'development') {
              console.warn('`invalidates` has been renamed to `invalidatesTags`, please change your code accordingly');
            }

            (_x$invalidatesTags = x.invalidatesTags) != null ? _x$invalidatesTags : x.invalidatesTags = x.invalidates;
          }

          return { ...x,
            type: DefinitionType.mutation
          };
        }
      });

      for (const [endpointName, definition] of Object.entries(evaluatedEndpoints)) {
        if (typeof process !== 'undefined' && process.env.NODE_ENV === 'development') {
          if (!inject.overrideExisting && endpointName in context.endpointDefinitions) {
            console.error(`called \`injectEndpoints\` to override already-existing endpointName ${endpointName} without specifying \`overrideExisting: true\``);
            continue;
          }
        }

        context.endpointDefinitions[endpointName] = definition;

        for (const m of initializedModules) {
          m.injectEndpoint(endpointName, definition);
        }
      }

      return api;
    }

    return api.injectEndpoints({
      endpoints: options.endpoints
    });
  };
}

export { buildCreateApi };
//# sourceMappingURL=createApi.js.map
