import { isPlainObject } from '@reduxjs/toolkit';
import { joinUrls } from './utils/joinUrls.js';

const defaultValidateStatus = response => response.status >= 200 && response.status <= 299;

const isJsonContentType = headers => {
  var _headers$get, _headers$get$trim;

  return (_headers$get = headers.get('content-type')) == null ? void 0 : (_headers$get$trim = _headers$get.trim()) == null ? void 0 : _headers$get$trim.startsWith('application/json');
};

const handleResponse = async (response, responseHandler) => {
  if (typeof responseHandler === 'function') {
    return responseHandler(response);
  }

  if (responseHandler === 'text') {
    return response.text();
  }

  if (responseHandler === 'json') {
    const text = await response.text();
    return text.length ? JSON.parse(text) : undefined;
  }
};

function stripUndefined(obj) {
  if (!isPlainObject(obj)) {
    return obj;
  }

  const copy = { ...obj
  };

  for (const [k, v] of Object.entries(copy)) {
    if (typeof v === 'undefined') delete copy[k];
  }

  return copy;
}
/**
 * This is a very small wrapper around fetch that aims to simplify requests.
 *
 * @example
 * ```ts
 * const baseQuery = fetchBaseQuery({
 *   baseUrl: 'https://api.your-really-great-app.com/v1/',
 *   prepareHeaders: (headers, { getState }) => {
 *     const token = (getState() as RootState).auth.token;
 *     // If we have a token set in state, let's assume that we should be passing it.
 *     if (token) {
 *       headers.set('authorization', `Bearer ${token}`);
 *     }
 *     return headers;
 *   },
 * })
 * ```
 *
 * @param {string} baseUrl
 * The base URL for an API service.
 * Typically in the format of http://example.com/
 *
 * @param {(headers: Headers, api: { getState: () => unknown }) => Headers} prepareHeaders
 * An optional function that can be used to inject headers on requests.
 * Provides a Headers object, as well as the `getState` function from the
 * redux store. Can be useful for authentication.
 *
 * @link https://developer.mozilla.org/en-US/docs/Web/API/Headers
 *
 * @param {(input: RequestInfo, init?: RequestInit | undefined) => Promise<Response>} fetchFn
 * Accepts a custom `fetch` function if you do not want to use the default on the window.
 * Useful in SSR environments if you need to use a library such as `isomorphic-fetch` or `cross-fetch`
 *
 */


function fetchBaseQuery({
  baseUrl,
  prepareHeaders = x => x,
  fetchFn = fetch,
  ...baseFetchOptions
} = {}) {
  return async (arg, {
    signal,
    getState
  }) => {
    let {
      url,
      method = 'GET',
      headers = new Headers({}),
      body = undefined,
      params = undefined,
      responseHandler = 'json',
      validateStatus = defaultValidateStatus,
      ...rest
    } = typeof arg == 'string' ? {
      url: arg
    } : arg;
    let config = { ...baseFetchOptions,
      method,
      signal,
      body,
      ...rest
    };
    config.headers = await prepareHeaders(new Headers(stripUndefined(headers)), {
      getState
    }); // Only set the content-type to json if appropriate. Will not be true for FormData, ArrayBuffer, Blob, etc.

    const isJsonifiable = body => typeof body === 'object' && (isPlainObject(body) || Array.isArray(body) || typeof body.toJSON === 'function');

    if (!config.headers.has('content-type') && isJsonifiable(body)) {
      config.headers.set('content-type', 'application/json');
    }

    if (body && isJsonContentType(config.headers)) {
      config.body = JSON.stringify(body);
    }

    if (params) {
      const divider = ~url.indexOf('?') ? '&' : '?';
      const query = new URLSearchParams(stripUndefined(params));
      url += divider + query;
    }

    url = joinUrls(baseUrl, url);
    const request = new Request(url, config);
    const requestClone = request.clone();
    const response = await fetchFn(request);
    const responseClone = response.clone();
    const meta = {
      request: requestClone,
      response: responseClone
    };
    const resultData = await handleResponse(response, responseHandler);
    return validateStatus(response, resultData) ? {
      data: resultData,
      meta
    } : {
      error: {
        status: response.status,
        data: resultData
      },
      meta
    };
  };
}

export { fetchBaseQuery };
//# sourceMappingURL=fetchBaseQuery.js.map
