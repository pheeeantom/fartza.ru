import { EndpointDefinitions, QueryDefinition, MutationDefinition, QueryArgFrom, ResultTypeFrom } from '../endpointDefinitions';
import type { QueryThunkArg, MutationThunkArg } from './buildThunks';
import { AnyAction, AsyncThunk, ThunkAction } from '@reduxjs/toolkit';
import { QuerySubState, SubscriptionOptions } from './apiState';
import { InternalSerializeQueryArgs } from '../defaultSerializeQueryArgs';
import { Api } from '../apiTypes';
import { BaseQueryResult } from '../baseQueryTypes';
declare module './module' {
    interface ApiEndpointQuery<Definition extends QueryDefinition<any, any, any, any, any>, Definitions extends EndpointDefinitions> {
        initiate: StartQueryActionCreator<Definition>;
    }
    interface ApiEndpointMutation<Definition extends MutationDefinition<any, any, any, any, any>, Definitions extends EndpointDefinitions> {
        initiate: StartMutationActionCreator<Definition>;
    }
}
export interface StartQueryActionCreatorOptions {
    subscribe?: boolean;
    forceRefetch?: boolean | number;
    subscriptionOptions?: SubscriptionOptions;
}
declare type StartQueryActionCreator<D extends QueryDefinition<any, any, any, any, any>> = (arg: QueryArgFrom<D>, options?: StartQueryActionCreatorOptions) => ThunkAction<QueryActionCreatorResult<D>, any, any, AnyAction>;
export declare type QueryActionCreatorResult<D extends QueryDefinition<any, any, any, any>> = Promise<QuerySubState<D>> & {
    arg: QueryArgFrom<D>;
    requestId: string;
    subscriptionOptions: SubscriptionOptions | undefined;
    abort(): void;
    unsubscribe(): void;
    refetch(): void;
    updateSubscriptionOptions(options: SubscriptionOptions): void;
};
declare type StartMutationActionCreator<D extends MutationDefinition<any, any, any, any>> = (arg: QueryArgFrom<D>, options?: {
    /**
     * If this mutation should be tracked in the store.
     * If you just want to manually trigger this mutation using `dispatch` and don't care about the
     * result, state & potential errors being held in store, you can set this to false.
     * (defaults to `true`)
     */
    track?: boolean;
}) => ThunkAction<MutationActionCreatorResult<D>, any, any, AnyAction>;
export declare type MutationActionCreatorResult<D extends MutationDefinition<any, any, any, any>> = Promise<ReturnType<BaseQueryResult<D extends MutationDefinition<any, infer BaseQuery, any, any> ? BaseQuery : never>>> & {
    arg: QueryArgFrom<D>;
    requestId: string;
    abort(): void;
    unwrap(): Promise<ResultTypeFrom<D>>;
    unsubscribe(): void;
};
export declare function buildInitiate<InternalQueryArgs>({ serializeQueryArgs, queryThunk, mutationThunk, api, }: {
    serializeQueryArgs: InternalSerializeQueryArgs<InternalQueryArgs>;
    queryThunk: AsyncThunk<any, QueryThunkArg<any>, {}>;
    mutationThunk: AsyncThunk<any, MutationThunkArg<any>, {}>;
    api: Api<any, EndpointDefinitions, any, any>;
}): {
    buildInitiateQuery: (endpointName: string, endpointDefinition: QueryDefinition<any, any, any, any>) => StartQueryActionCreator<any>;
    buildInitiateMutation: (endpointName: string, definition: MutationDefinition<any, any, any, any>) => StartMutationActionCreator<any>;
};
export {};
//# sourceMappingURL=buildInitiate.d.ts.map