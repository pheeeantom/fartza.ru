import { InternalSerializeQueryArgs } from '../defaultSerializeQueryArgs';
import { Api, ApiContext } from '../apiTypes';
import { BaseQueryFn, BaseQueryArg, BaseQueryError } from '../baseQueryTypes';
import { RootState, QueryKeys, QuerySubstateIdentifier } from './apiState';
import { StartQueryActionCreatorOptions } from './buildInitiate';
import { AssertTagTypes, EndpointDefinition, EndpointDefinitions, MutationDefinition, QueryArgFrom, QueryDefinition, ResultTypeFrom } from '../endpointDefinitions';
import { Draft } from '@reduxjs/toolkit';
import { Patch } from 'immer';
import { AnyAction, ThunkAction, AsyncThunk } from '@reduxjs/toolkit';
import { PrefetchOptions } from './module';
import { UnwrapPromise } from '../tsHelpers';
declare module './module' {
    interface ApiEndpointQuery<Definition extends QueryDefinition<any, any, any, any, any>, Definitions extends EndpointDefinitions> extends Matchers<QueryThunk, Definition> {
    }
    interface ApiEndpointMutation<Definition extends MutationDefinition<any, any, any, any, any>, Definitions extends EndpointDefinitions> extends Matchers<MutationThunk, Definition> {
    }
}
declare type EndpointThunk<Thunk extends AsyncThunk<any, any, any>, Definition extends EndpointDefinition<any, any, any, any>> = Definition extends EndpointDefinition<infer QueryArg, infer BaseQueryFn, any, infer ResultType> ? Thunk extends AsyncThunk<infer ATResult, infer ATArg, infer ATConfig> ? AsyncThunk<ATResult & {
    result: ResultType;
}, ATArg & {
    originalArgs: QueryArg;
}, ATConfig & {
    rejectValue: BaseQueryError<BaseQueryFn>;
}> : never : never;
export declare type PendingAction<Thunk extends AsyncThunk<any, any, any>, Definition extends EndpointDefinition<any, any, any, any>> = ReturnType<EndpointThunk<Thunk, Definition>['pending']>;
export declare type FulfilledAction<Thunk extends AsyncThunk<any, any, any>, Definition extends EndpointDefinition<any, any, any, any>> = ReturnType<EndpointThunk<Thunk, Definition>['fulfilled']>;
export declare type RejectedAction<Thunk extends AsyncThunk<any, any, any>, Definition extends EndpointDefinition<any, any, any, any>> = ReturnType<EndpointThunk<Thunk, Definition>['rejected']>;
export declare type Matcher<M> = (value: any) => value is M;
export interface Matchers<Thunk extends AsyncThunk<any, any, any>, Definition extends EndpointDefinition<any, any, any, any>> {
    matchPending: Matcher<PendingAction<Thunk, Definition>>;
    matchFulfilled: Matcher<FulfilledAction<Thunk, Definition>>;
    matchRejected: Matcher<RejectedAction<Thunk, Definition>>;
}
export interface QueryThunkArg<_InternalQueryArgs> extends QuerySubstateIdentifier, StartQueryActionCreatorOptions {
    originalArgs: unknown;
    endpointName: string;
    startedTimeStamp: number;
}
export interface MutationThunkArg<_InternalQueryArgs> {
    originalArgs: unknown;
    endpointName: string;
    track?: boolean;
    startedTimeStamp: number;
}
export interface ThunkResult {
    fulfilledTimeStamp: number;
    result: unknown;
}
export declare type QueryThunk = AsyncThunk<ThunkResult, QueryThunkArg<any>, {}>;
export declare type MutationThunk = AsyncThunk<ThunkResult, MutationThunkArg<any>, {}>;
declare type MaybeDrafted<T> = T | Draft<T>;
declare type Recipe<T> = (data: MaybeDrafted<T>) => void | MaybeDrafted<T>;
export declare type PatchQueryResultThunk<Definitions extends EndpointDefinitions, PartialState> = <EndpointName extends QueryKeys<Definitions>>(endpointName: EndpointName, args: QueryArgFrom<Definitions[EndpointName]>, patches: Patch[]) => ThunkAction<void, PartialState, any, AnyAction>;
export declare type UpdateQueryResultThunk<Definitions extends EndpointDefinitions, PartialState> = <EndpointName extends QueryKeys<Definitions>>(endpointName: EndpointName, args: QueryArgFrom<Definitions[EndpointName]>, updateRecipe: Recipe<ResultTypeFrom<Definitions[EndpointName]>>) => ThunkAction<PatchCollection, PartialState, any, AnyAction>;
declare type PatchCollection = {
    patches: Patch[];
    inversePatches: Patch[];
};
export declare function buildThunks<BaseQuery extends BaseQueryFn, ReducerPath extends string, Definitions extends EndpointDefinitions>({ reducerPath, baseQuery, context: { endpointDefinitions }, serializeQueryArgs, api, }: {
    baseQuery: BaseQuery;
    reducerPath: ReducerPath;
    context: ApiContext<Definitions>;
    serializeQueryArgs: InternalSerializeQueryArgs<BaseQueryArg<BaseQuery>>;
    api: Api<BaseQuery, EndpointDefinitions, ReducerPath, any>;
}): {
    queryThunk: AsyncThunk<ThunkResult, QueryThunkArg<BaseQuery extends (arg: infer A, ...args: any[]) => any ? A : any>, {
        state: RootState<any, string, ReducerPath>;
    }>;
    mutationThunk: AsyncThunk<ThunkResult, MutationThunkArg<BaseQuery extends (arg: infer A, ...args: any[]) => any ? A : any>, {
        state: RootState<any, string, ReducerPath>;
    }>;
    prefetch: <EndpointName extends never>(endpointName: EndpointName, arg: any, options: PrefetchOptions) => ThunkAction<void, any, any, AnyAction>;
    updateQueryResult: UpdateQueryResultThunk<EndpointDefinitions, { [P in ReducerPath]: import("./apiState").CombinedState<any, string, P>; }>;
    patchQueryResult: PatchQueryResultThunk<EndpointDefinitions, { [P in ReducerPath]: import("./apiState").CombinedState<any, string, P>; }>;
    buildMatchThunkActions: <Thunk extends AsyncThunk<any, QueryThunkArg<any>, any> | AsyncThunk<any, MutationThunkArg<any>, any>>(thunk: Thunk, endpointName: string) => Matchers<Thunk, any>;
};
export declare function calculateProvidedByThunk(action: UnwrapPromise<ReturnType<ReturnType<QueryThunk>> | ReturnType<ReturnType<MutationThunk>>>, type: 'providesTags' | 'invalidatesTags', endpointDefinitions: EndpointDefinitions, assertTagType: AssertTagTypes): readonly import("../endpointDefinitions").FullTagDescription<string>[];
export {};
//# sourceMappingURL=buildThunks.d.ts.map