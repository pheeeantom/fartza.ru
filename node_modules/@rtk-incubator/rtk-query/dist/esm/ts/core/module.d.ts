/**
 * Note: this file should import all other files for type discovery and declaration merging
 */
import { PatchQueryResultThunk, UpdateQueryResultThunk } from './buildThunks';
import { ActionCreatorWithPayload, AnyAction, Middleware, Reducer, ThunkAction, ThunkDispatch } from '@reduxjs/toolkit';
import { EndpointDefinitions, QueryArgFrom, QueryDefinition, MutationDefinition, FullTagDescription } from '../endpointDefinitions';
import { CombinedState, QueryKeys, RootState } from './apiState';
import './buildSelectors';
import { Module } from '../apiTypes';
import { onFocus, onFocusLost, onOnline, onOffline } from './setupListeners';
import './buildSelectors';
import './buildInitiate';
import { Id } from '../tsHelpers';
import { SliceActions } from './buildSlice';
import { BaseQueryFn } from '../baseQueryTypes';
/**
 * `ifOlderThan` - (default: `false` | `number`) - _number is value in seconds_
 * - If specified, it will only run the query if the difference between `new Date()` and the last `fulfilledTimeStamp` is greater than the given value
 *
 * @overloadSummary
 * `force`
 * - If `force: true`, it will ignore the `ifOlderThan` value if it is set and the query will be run even if it exists in the cache.
 */
export declare type PrefetchOptions = {
    ifOlderThan?: false | number;
} | {
    force?: boolean;
};
export declare const coreModuleName: unique symbol;
export declare type CoreModule = typeof coreModuleName;
declare module '../apiTypes' {
    interface ApiModules<BaseQuery extends BaseQueryFn, Definitions extends EndpointDefinitions, ReducerPath extends string, TagTypes extends string> {
        [coreModuleName]: {
            /**
             * This api's reducer should be mounted at `store[api.reducerPath]`.
             *
             * @example
             * ```ts
             * configureStore({
             *   reducer: {
             *     [api.reducerPath]: api.reducer,
             *   },
             *   middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(api.middleware),
             * })
             * ```
             */
            reducerPath: ReducerPath;
            /**
             * Internal actions not part of the public API. Note: These are subject to change at any given time.
             */
            internalActions: InternalActions;
            /**
             *  A standard redux reducer that enables core functionality. Make sure it's included in your store.
             *
             * @example
             * ```ts
             * configureStore({
             *   reducer: {
             *     [api.reducerPath]: api.reducer,
             *   },
             *   middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(api.middleware),
             * })
             * ```
             */
            reducer: Reducer<CombinedState<Definitions, TagTypes, ReducerPath>, AnyAction>;
            /**
             * This is a standard redux middleware and is responsible for things like polling, garbage collection and a handful of other things. Make sure it's included in your store.
             *
             * @example
             * ```ts
             * configureStore({
             *   reducer: {
             *     [api.reducerPath]: api.reducer,
             *   },
             *   middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(api.middleware),
             * })
             * ```
             */
            middleware: Middleware<{}, RootState<Definitions, string, ReducerPath>, ThunkDispatch<any, any, AnyAction>>;
            /**
             * TODO
             */
            util: {
                /**
                 * TODO
                 */
                prefetch<EndpointName extends QueryKeys<EndpointDefinitions>>(endpointName: EndpointName, arg: QueryArgFrom<Definitions[EndpointName]>, options: PrefetchOptions): ThunkAction<void, any, any, AnyAction>;
                prefetchThunk<EndpointName extends QueryKeys<EndpointDefinitions>>(endpointName: EndpointName, arg: QueryArgFrom<Definitions[EndpointName]>, options: PrefetchOptions): ThunkAction<void, any, any, AnyAction>;
                /**
                 * TODO
                 */
                updateQueryResult: UpdateQueryResultThunk<Definitions, RootState<Definitions, string, ReducerPath>>;
                /**
                 * TODO
                 */
                patchQueryResult: PatchQueryResultThunk<Definitions, RootState<Definitions, string, ReducerPath>>;
                /**
                 * TODO
                 */
                resetApiState: SliceActions['resetApiState'];
                /**
                 * TODO
                 */
                invalidateTags: ActionCreatorWithPayload<Array<TagTypes | FullTagDescription<TagTypes>>, string>;
                /** @deprecated renamed to `invalidateTags` */
                invalidateEntities: ActionCreatorWithPayload<Array<TagTypes | FullTagDescription<TagTypes>>, string>;
            };
            /**
             * Endpoints based on the input endpoints provided to `createApi`, containing `select` and `action matchers`.
             */
            endpoints: {
                [K in keyof Definitions]: Definitions[K] extends QueryDefinition<any, any, any, any, any> ? Id<ApiEndpointQuery<Definitions[K], Definitions>> : Definitions[K] extends MutationDefinition<any, any, any, any, any> ? Id<ApiEndpointMutation<Definitions[K], Definitions>> : never;
            };
        };
    }
}
export interface ApiEndpointQuery<Definition extends QueryDefinition<any, any, any, any, any>, Definitions extends EndpointDefinitions> {
}
export interface ApiEndpointMutation<Definition extends MutationDefinition<any, any, any, any, any>, Definitions extends EndpointDefinitions> {
}
export declare type ListenerActions = {
    /**
     * Will cause the RTK Query middleware to trigger any refetchOnReconnect-related behavior
     * @link https://rtk-query-docs.netlify.app/api/setupListeners
     */
    onOnline: typeof onOnline;
    onOffline: typeof onOffline;
    /**
     * Will cause the RTK Query middleware to trigger any refetchOnFocus-related behavior
     * @link https://rtk-query-docs.netlify.app/api/setupListeners
     */
    onFocus: typeof onFocus;
    onFocusLost: typeof onFocusLost;
};
export declare type InternalActions = SliceActions & ListenerActions;
/**
 * Creates a module containing the basic redux logic for use with `buildCreateApi`.
 *
 * @example
 * ```ts
 * const createBaseApi = buildCreateApi(coreModule());
 * ```
 */
export declare const coreModule: () => Module<CoreModule>;
//# sourceMappingURL=module.d.ts.map