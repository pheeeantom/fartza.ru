'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _typeof = require('@babel/runtime/helpers/typeof');
var _objectWithoutProperties = require('@babel/runtime/helpers/objectWithoutProperties');
var _slicedToArray = require('@babel/runtime/helpers/slicedToArray');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');
var _regeneratorRuntime = require('@babel/runtime/regenerator');
var toolkit = require('@reduxjs/toolkit');
var _classCallCheck = require('@babel/runtime/helpers/classCallCheck');
var _toConsumableArray = require('@babel/runtime/helpers/toConsumableArray');
var immer = require('immer');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _typeof__default = /*#__PURE__*/_interopDefaultLegacy(_typeof);
var _objectWithoutProperties__default = /*#__PURE__*/_interopDefaultLegacy(_objectWithoutProperties);
var _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);
var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
var _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);
var _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_regeneratorRuntime);
var _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);
var _toConsumableArray__default = /*#__PURE__*/_interopDefaultLegacy(_toConsumableArray);

/**
 * Strings describing the query state at any given time.
 */
exports.QueryStatus = void 0;

(function (QueryStatus) {
  QueryStatus["uninitialized"] = "uninitialized";
  QueryStatus["pending"] = "pending";
  QueryStatus["fulfilled"] = "fulfilled";
  QueryStatus["rejected"] = "rejected";
})(exports.QueryStatus || (exports.QueryStatus = {}));

function getRequestStatusFlags(status) {
  return {
    status: status,
    isUninitialized: status === exports.QueryStatus.uninitialized,
    isLoading: status === exports.QueryStatus.pending,
    isSuccess: status === exports.QueryStatus.fulfilled,
    isError: status === exports.QueryStatus.rejected
  };
}

/**
 * If either :// or // is present consider it to be an absolute url
 *
 * @param url string
 */
function isAbsoluteUrl(url) {
  return new RegExp("(^|:)//").test(url);
}

var withoutTrailingSlash = function withoutTrailingSlash(url) {
  return url.replace(/\/$/, '');
};

var withoutLeadingSlash = function withoutLeadingSlash(url) {
  return url.replace(/^\//, '');
};

function joinUrls(base, url) {
  if (!base) {
    return url;
  }

  if (!url) {
    return base;
  }

  if (isAbsoluteUrl(url)) {
    return url;
  }

  base = withoutTrailingSlash(base);
  url = withoutLeadingSlash(url);
  return "".concat(base, "/").concat(url);
}

/**
 * Alternative to `Array.flat(1)`
 * @param arr An array like [1,2,3,[1,2]]
 * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat
 */
var flatten = function flatten(arr) {
  var _ref;

  return (_ref = []).concat.apply(_ref, _toConsumableArray__default['default'](arr));
};

/**
 * Assumes a browser is online if `undefined`, otherwise makes a best effort
 * @link https://developer.mozilla.org/en-US/docs/Web/API/NavigatorOnLine/onLine
 */
function isOnline() {
  // We set the default config value in the store, so we'd need to check for this in a SSR env
  return typeof navigator === 'undefined' ? true : navigator.onLine === undefined ? true : navigator.onLine;
}

/**
 * Assumes true for a non-browser env, otherwise makes a best effort
 * @link https://developer.mozilla.org/en-US/docs/Web/API/Document/visibilityState
 */
function isDocumentVisible() {
  // `document` may not exist in non-browser envs (like RN)
  if (typeof document === 'undefined') {
    return true;
  } // Match true for visible, prerender, undefined


  return document.visibilityState !== 'hidden';
}

var isPlainObject = toolkit.isPlainObject;
function copyWithStructuralSharing(oldObj, newObj) {
  if (oldObj === newObj || !(isPlainObject(oldObj) && isPlainObject(newObj) || Array.isArray(oldObj) && Array.isArray(newObj))) {
    return newObj;
  }

  var newKeys = Object.keys(newObj);
  var oldKeys = Object.keys(oldObj);
  var isSameObject = newKeys.length === oldKeys.length;
  var mergeObj = Array.isArray(newObj) ? [] : {};

  for (var _i = 0, _newKeys = newKeys; _i < _newKeys.length; _i++) {
    var key = _newKeys[_i];
    mergeObj[key] = copyWithStructuralSharing(oldObj[key], newObj[key]);
    if (isSameObject) isSameObject = oldObj[key] === mergeObj[key];
  }

  return isSameObject ? oldObj : mergeObj;
}

function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var defaultValidateStatus = function defaultValidateStatus(response) {
  return response.status >= 200 && response.status <= 299;
};

var isJsonContentType = function isJsonContentType(headers) {
  var _headers$get, _headers$get$trim;

  return (_headers$get = headers.get('content-type')) === null || _headers$get === void 0 ? void 0 : (_headers$get$trim = _headers$get.trim()) === null || _headers$get$trim === void 0 ? void 0 : _headers$get$trim.startsWith('application/json');
};

var handleResponse = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(response, responseHandler) {
    var text;
    return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(typeof responseHandler === 'function')) {
              _context.next = 2;
              break;
            }

            return _context.abrupt("return", responseHandler(response));

          case 2:
            if (!(responseHandler === 'text')) {
              _context.next = 4;
              break;
            }

            return _context.abrupt("return", response.text());

          case 4:
            if (!(responseHandler === 'json')) {
              _context.next = 9;
              break;
            }

            _context.next = 7;
            return response.text();

          case 7:
            text = _context.sent;
            return _context.abrupt("return", text.length ? JSON.parse(text) : undefined);

          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function handleResponse(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

function stripUndefined(obj) {
  if (!toolkit.isPlainObject(obj)) {
    return obj;
  }

  var copy = _objectSpread$6({}, obj);

  for (var _i = 0, _Object$entries = Object.entries(copy); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray__default['default'](_Object$entries[_i], 2),
        k = _Object$entries$_i[0],
        v = _Object$entries$_i[1];

    if (typeof v === 'undefined') delete copy[k];
  }

  return copy;
}
/**
 * This is a very small wrapper around fetch that aims to simplify requests.
 *
 * @example
 * ```ts
 * const baseQuery = fetchBaseQuery({
 *   baseUrl: 'https://api.your-really-great-app.com/v1/',
 *   prepareHeaders: (headers, { getState }) => {
 *     const token = (getState() as RootState).auth.token;
 *     // If we have a token set in state, let's assume that we should be passing it.
 *     if (token) {
 *       headers.set('authorization', `Bearer ${token}`);
 *     }
 *     return headers;
 *   },
 * })
 * ```
 *
 * @param {string} baseUrl
 * The base URL for an API service.
 * Typically in the format of http://example.com/
 *
 * @param {(headers: Headers, api: { getState: () => unknown }) => Headers} prepareHeaders
 * An optional function that can be used to inject headers on requests.
 * Provides a Headers object, as well as the `getState` function from the
 * redux store. Can be useful for authentication.
 *
 * @link https://developer.mozilla.org/en-US/docs/Web/API/Headers
 *
 * @param {(input: RequestInfo, init?: RequestInit | undefined) => Promise<Response>} fetchFn
 * Accepts a custom `fetch` function if you do not want to use the default on the window.
 * Useful in SSR environments if you need to use a library such as `isomorphic-fetch` or `cross-fetch`
 *
 */


function fetchBaseQuery() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      baseUrl = _ref2.baseUrl,
      _ref2$prepareHeaders = _ref2.prepareHeaders,
      prepareHeaders = _ref2$prepareHeaders === void 0 ? function (x) {
    return x;
  } : _ref2$prepareHeaders,
      _ref2$fetchFn = _ref2.fetchFn,
      fetchFn = _ref2$fetchFn === void 0 ? fetch : _ref2$fetchFn,
      baseFetchOptions = _objectWithoutProperties__default['default'](_ref2, ["baseUrl", "prepareHeaders", "fetchFn"]);

  return /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(arg, _ref3) {
      var signal, getState, _ref5, url, _ref5$method, method, _ref5$headers, headers, _ref5$body, body, _ref5$params, params, _ref5$responseHandler, responseHandler, _ref5$validateStatus, validateStatus, rest, config, isJsonifiable, divider, query, request, requestClone, response, responseClone, meta, resultData;

      return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              signal = _ref3.signal, getState = _ref3.getState;
              _ref5 = typeof arg == 'string' ? {
                url: arg
              } : arg, url = _ref5.url, _ref5$method = _ref5.method, method = _ref5$method === void 0 ? 'GET' : _ref5$method, _ref5$headers = _ref5.headers, headers = _ref5$headers === void 0 ? new Headers({}) : _ref5$headers, _ref5$body = _ref5.body, body = _ref5$body === void 0 ? undefined : _ref5$body, _ref5$params = _ref5.params, params = _ref5$params === void 0 ? undefined : _ref5$params, _ref5$responseHandler = _ref5.responseHandler, responseHandler = _ref5$responseHandler === void 0 ? 'json' : _ref5$responseHandler, _ref5$validateStatus = _ref5.validateStatus, validateStatus = _ref5$validateStatus === void 0 ? defaultValidateStatus : _ref5$validateStatus, rest = _objectWithoutProperties__default['default'](_ref5, ["url", "method", "headers", "body", "params", "responseHandler", "validateStatus"]);
              config = _objectSpread$6(_objectSpread$6({}, baseFetchOptions), {}, {
                method: method,
                signal: signal,
                body: body
              }, rest);
              _context2.next = 5;
              return prepareHeaders(new Headers(stripUndefined(headers)), {
                getState: getState
              });

            case 5:
              config.headers = _context2.sent;

              // Only set the content-type to json if appropriate. Will not be true for FormData, ArrayBuffer, Blob, etc.
              isJsonifiable = function isJsonifiable(body) {
                return _typeof__default['default'](body) === 'object' && (toolkit.isPlainObject(body) || Array.isArray(body) || typeof body.toJSON === 'function');
              };

              if (!config.headers.has('content-type') && isJsonifiable(body)) {
                config.headers.set('content-type', 'application/json');
              }

              if (body && isJsonContentType(config.headers)) {
                config.body = JSON.stringify(body);
              }

              if (params) {
                divider = ~url.indexOf('?') ? '&' : '?';
                query = new URLSearchParams(stripUndefined(params));
                url += divider + query;
              }

              url = joinUrls(baseUrl, url);
              request = new Request(url, config);
              requestClone = request.clone();
              _context2.next = 15;
              return fetchFn(request);

            case 15:
              response = _context2.sent;
              responseClone = response.clone();
              meta = {
                request: requestClone,
                response: responseClone
              };
              _context2.next = 20;
              return handleResponse(response, responseHandler);

            case 20:
              resultData = _context2.sent;
              return _context2.abrupt("return", validateStatus(response, resultData) ? {
                data: resultData,
                meta: meta
              } : {
                error: {
                  status: response.status,
                  data: resultData
                },
                meta: meta
              });

            case 22:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function (_x3, _x4) {
      return _ref4.apply(this, arguments);
    };
  }();
}

var HandledError = function HandledError(value) {
  var meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

  _classCallCheck__default['default'](this, HandledError);

  this.value = value;
  this.meta = meta;
};

function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
/**
 * Exponential backoff based on the attempt number.
 *
 * @remarks
 * 1. 600ms * random(0.4, 1.4)
 * 2. 1200ms * random(0.4, 1.4)
 * 3. 2400ms * random(0.4, 1.4)
 * 4. 4800ms * random(0.4, 1.4)
 * 5. 9600ms * random(0.4, 1.4)
 *
 * @param attempt - Current attempt
 * @param maxRetries - Maximum number of retries
 */

function defaultBackoff() {
  return _defaultBackoff.apply(this, arguments);
}

function _defaultBackoff() {
  _defaultBackoff = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {
    var attempt,
        maxRetries,
        attempts,
        timeout,
        _args2 = arguments;
    return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            attempt = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : 0;
            maxRetries = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : 5;
            attempts = Math.min(attempt, maxRetries);
            timeout = ~~((Math.random() + 0.4) * (300 << attempts)); // Force a positive int in the case we make this an option

            _context2.next = 6;
            return new Promise(function (resolve) {
              return setTimeout(function (res) {
                return resolve(res);
              }, timeout);
            });

          case 6:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _defaultBackoff.apply(this, arguments);
}

function fail(e) {
  throw Object.assign(new HandledError({
    error: e
  }), {
    throwImmediately: true
  });
}

var retryWithBackoff = function retryWithBackoff(baseQuery, defaultOptions) {
  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(args, api, extraOptions) {
      var options, retry, result;
      return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              options = _objectSpread$5(_objectSpread$5({
                maxRetries: 5,
                backoff: defaultBackoff
              }, defaultOptions), extraOptions);
              retry = 0;

            case 2:

              _context.prev = 3;
              _context.next = 6;
              return baseQuery(args, api, extraOptions);

            case 6:
              result = _context.sent;

              if (!result.error) {
                _context.next = 9;
                break;
              }

              throw new HandledError(result);

            case 9:
              return _context.abrupt("return", result);

            case 12:
              _context.prev = 12;
              _context.t0 = _context["catch"](3);
              retry++;

              if (!(_context.t0.throwImmediately || retry > options.maxRetries)) {
                _context.next = 19;
                break;
              }

              if (!(_context.t0 instanceof HandledError)) {
                _context.next = 18;
                break;
              }

              return _context.abrupt("return", _context.t0.value);

            case 18:
              throw _context.t0;

            case 19:
              _context.next = 21;
              return options.backoff(retry, options.maxRetries);

            case 21:
              _context.next = 2;
              break;

            case 23:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[3, 12]]);
    }));

    return function (_x, _x2, _x3) {
      return _ref.apply(this, arguments);
    };
  }();
};
/**
 * A utility that can wrap `baseQuery` in the API definition to provide retries with a basic exponential backoff.
 *
 * @example
 *
 * ```ts
 * // codeblock-meta title="Retry every request 5 times by default"
 * // maxRetries: 5 is the default, and can be omitted. Shown for documentation purposes.
 * const staggeredBaseQuery = retry(fetchBaseQuery({ baseUrl: '/' }), { maxRetries: 5 });
 *
 * export const api = createApi({
 *   baseQuery: staggeredBaseQuery,
 *   endpoints: (build) => ({
 *     getPosts: build.query<PostsResponse, void>({
 *       query: () => ({ url: 'posts' }),
 *     }),
 *     getPost: build.query<PostsResponse, void>({
 *       query: (id: string) => ({ url: `posts/${id}` }),
 *       extraOptions: { maxRetries: 8 }, // You can override the retry behavior on each endpoint
 *     }),
 *   }),
 * });
 *
 * export const { useGetPostsQuery, useGetPostQuery } = api;
 * ```
 */


var retry = Object.assign(retryWithBackoff, {
  fail: fail
});

var onFocus = toolkit.createAction('__rtkq/focused');
var onFocusLost = toolkit.createAction('__rtkq/unfocused');
var onOnline = toolkit.createAction('__rtkq/online');
var onOffline = toolkit.createAction('__rtkq/offline');
var initialized = false;
/**
 * A utility used to enable `refetchOnMount` and `refetchOnReconnect` behaviors.
 * It requires the dispatch method from your store.
 * Calling `setupListeners(store.dispatch)` will configure listeners with the recommended defaults,
 * but you have the option of providing a callback for more granular control.
 *
 * @example
 * ```ts
 * setupListeners(store.dispatch)
 * ```
 *
 * @param dispatch - The dispatch method from your store
 * @param customHandler - An optional callback for more granular control over listener behavior
 * @returns Return value of the handler.
 * The default handler returns an `unsubscribe` method that can be called to remove the listeners.
 */

function setupListeners(dispatch, customHandler) {
  function defaultHandler() {
    var handleFocus = function handleFocus() {
      return dispatch(onFocus());
    };

    var handleFocusLost = function handleFocusLost() {
      return dispatch(onFocusLost());
    };

    var handleOnline = function handleOnline() {
      return dispatch(onOnline());
    };

    var handleOffline = function handleOffline() {
      return dispatch(onOffline());
    };

    var handleVisibilityChange = function handleVisibilityChange() {
      if (window.document.visibilityState === 'visible') {
        handleFocus();
      } else {
        handleFocusLost();
      }
    };

    if (!initialized) {
      if (typeof window !== 'undefined' && window.addEventListener) {
        // Handle focus events
        window.addEventListener('visibilitychange', handleVisibilityChange, false);
        window.addEventListener('focus', handleFocus, false); // Handle connection events

        window.addEventListener('online', handleOnline, false);
        window.addEventListener('offline', handleOffline, false);
        initialized = true;
      }
    }

    var unsubscribe = function unsubscribe() {
      window.removeEventListener('focus', handleFocus);
      window.removeEventListener('visibilitychange', handleVisibilityChange);
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
      initialized = false;
    };

    return unsubscribe;
  }

  return customHandler ? customHandler(dispatch, {
    onFocus: onFocus,
    onFocusLost: onFocusLost,
    onOffline: onOffline,
    onOnline: onOnline
  }) : defaultHandler();
}

function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var skipSelector = Symbol('skip selector');
var initialSubState = {
  status: exports.QueryStatus.uninitialized
}; // abuse immer to freeze default states

var defaultQuerySubState = toolkit.createNextState({}, function () {
  return initialSubState;
});
var defaultMutationSubState = toolkit.createNextState({}, function () {
  return initialSubState;
});
function buildSelectors(_ref) {
  var serializeQueryArgs = _ref.serializeQueryArgs,
      reducerPath = _ref.reducerPath;
  return {
    buildQuerySelector: buildQuerySelector,
    buildMutationSelector: buildMutationSelector
  };

  function withRequestFlags(substate) {
    return _objectSpread$4(_objectSpread$4({}, substate), getRequestStatusFlags(substate.status));
  }

  function selectInternalState(rootState) {
    return rootState[reducerPath];
  }

  function buildQuerySelector(endpointName, endpointDefinition) {
    return function (queryArgs) {
      var selectQuerySubState = toolkit.createSelector(selectInternalState, function (internalState) {
        var _ref2;

        return (_ref2 = queryArgs === skipSelector ? undefined : internalState.queries[serializeQueryArgs({
          queryArgs: queryArgs,
          endpointDefinition: endpointDefinition,
          endpointName: endpointName
        })]) !== null && _ref2 !== void 0 ? _ref2 : defaultQuerySubState;
      });
      return toolkit.createSelector(selectQuerySubState, withRequestFlags);
    };
  }

  function buildMutationSelector() {
    return function (mutationId) {
      var selectMutationSubstate = toolkit.createSelector(selectInternalState, function (internalState) {
        var _ref3;

        return (_ref3 = mutationId === skipSelector ? undefined : internalState.mutations[mutationId]) !== null && _ref3 !== void 0 ? _ref3 : defaultMutationSubState;
      });
      return toolkit.createSelector(selectMutationSubstate, withRequestFlags);
    };
  }
}

var defaultSerializeQueryArgs = function defaultSerializeQueryArgs(_ref) {
  var endpointName = _ref.endpointName,
      queryArgs = _ref.queryArgs;
  // Sort the object keys before stringifying, to prevent useQuery({ a: 1, b: 2 }) having a different cache key than useQuery({ b: 2, a: 1 })
  return "".concat(endpointName, "(").concat(JSON.stringify(queryArgs, Object.keys(queryArgs || {}).sort()), ")");
};

var DefinitionType;

(function (DefinitionType) {
  DefinitionType["query"] = "query";
  DefinitionType["mutation"] = "mutation";
})(DefinitionType || (DefinitionType = {}));

function isQueryDefinition(e) {
  return e.type === DefinitionType.query;
}
function isMutationDefinition(e) {
  return e.type === DefinitionType.mutation;
}
function calculateProvidedBy(description, result, error, queryArg, assertTagTypes) {
  if (isFunction(description)) {
    return description(result, error, queryArg).map(expandTagDescription).map(assertTagTypes);
  }

  if (Array.isArray(description)) {
    return description.map(expandTagDescription).map(assertTagTypes);
  }

  return [];
}

function isFunction(t) {
  return typeof t === 'function';
}

function expandTagDescription(description) {
  return typeof description === 'string' ? {
    type: description
  } : description;
}

function _createForOfIteratorHelper$2(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }

function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
/**
 * Builds a `createApi` method based on the provided `modules`.
 *
 * @link https://rtk-query-docs.netlify.app/concepts/customizing-create-api
 *
 * @example
 * ```ts
 * const MyContext = React.createContext<ReactReduxContextValue>(null as any);
 * const customCreateApi = buildCreateApi(
 *   coreModule(),
 *   reactHooksModule({ useDispatch: createDispatchHook(MyContext) })
 * );
 * ```
 *
 * @param modules - A variable number of modules that customize how the `createApi` method handles endpoints
 * @returns A `createApi` method using the provided `modules`.
 */

function buildCreateApi() {
  for (var _len = arguments.length, modules = new Array(_len), _key = 0; _key < _len; _key++) {
    modules[_key] = arguments[_key];
  }

  return function baseCreateApi(options) {
    // remove in final release
    if (options.entityTypes) {
      var _options$tagTypes;

      if (typeof process !== 'undefined' && "development" === 'development') {
        console.warn('`entityTypes` has been renamed to `tagTypes`, please change your code accordingly');
      }

      (_options$tagTypes = options.tagTypes) !== null && _options$tagTypes !== void 0 ? _options$tagTypes : options.tagTypes = options.entityTypes;
    }

    var optionsWithDefaults = _objectSpread$3(_objectSpread$3({
      reducerPath: 'api',
      serializeQueryArgs: defaultSerializeQueryArgs,
      keepUnusedDataFor: 60,
      refetchOnMountOrArgChange: false,
      refetchOnFocus: false,
      refetchOnReconnect: false
    }, options), {}, {
      entityTypes: [],
      tagTypes: _toConsumableArray__default['default'](options.tagTypes || [])
    });

    var context = {
      endpointDefinitions: {},
      batch: function batch(fn) {
        // placeholder "batch" method to be overridden by plugins, for example with React.unstable_batchedUpdate
        fn();
      }
    };
    var api = {
      injectEndpoints: injectEndpoints,
      enhanceEndpoints: function enhanceEndpoints(_ref) {
        var addTagTypes = _ref.addTagTypes,
            endpoints = _ref.endpoints,
            addEntityTypes = _ref.addEntityTypes;

        // remove in final release
        if (addEntityTypes) {
          var _addTagTypes;

          if (typeof process !== 'undefined' && "development" === 'development') {
            console.warn('`addEntityTypes` has been renamed to `addTagTypes`, please change your code accordingly');
          }

          (_addTagTypes = addTagTypes) !== null && _addTagTypes !== void 0 ? _addTagTypes : addTagTypes = addEntityTypes;
        }

        if (addTagTypes) {
          var _iterator = _createForOfIteratorHelper$2(addTagTypes),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var eT = _step.value;

              if (!optionsWithDefaults.tagTypes.includes(eT)) {
                optionsWithDefaults.tagTypes.push(eT);
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }

        if (endpoints) {
          for (var _i = 0, _Object$entries = Object.entries(endpoints); _i < _Object$entries.length; _i++) {
            var _Object$entries$_i = _slicedToArray__default['default'](_Object$entries[_i], 2),
                endpointName = _Object$entries$_i[0],
                partialDefinition = _Object$entries$_i[1];

            if (typeof partialDefinition === 'function') {
              partialDefinition(context.endpointDefinitions[endpointName]);
            }

            Object.assign(context.endpointDefinitions[endpointName] || {}, partialDefinition); // remove in final release

            var x = context.endpointDefinitions[endpointName];

            if (x !== null && x !== void 0 && x.provides) {
              if (typeof process !== 'undefined' && "development" === 'development') {
                console.warn('`provides` has been renamed to `providesTags`, please change your code accordingly');
              }

              x.providesTags = x.provides;
            }

            if (x !== null && x !== void 0 && x.invalidates) {
              if (typeof process !== 'undefined' && "development" === 'development') {
                console.warn('`invalidates` has been renamed to `invalidatesTags`, please change your code accordingly');
              }

              x.invalidatesTags = x.invalidates;
            }
          }
        }

        return api;
      }
    };
    var initializedModules = modules.map(function (m) {
      return m.init(api, optionsWithDefaults, context);
    });

    function injectEndpoints(inject) {
      var evaluatedEndpoints = inject.endpoints({
        query: function query(x) {
          // remove in final release
          if (x.provides) {
            var _x$providesTags;

            if (typeof process !== 'undefined' && "development" === 'development') {
              console.warn('`provides` has been renamed to `providesTags`, please change your code accordingly');
            }

            (_x$providesTags = x.providesTags) !== null && _x$providesTags !== void 0 ? _x$providesTags : x.providesTags = x.provides;
          }

          return _objectSpread$3(_objectSpread$3({}, x), {}, {
            type: DefinitionType.query
          });
        },
        mutation: function mutation(x) {
          // remove in final release
          if (x.invalidates) {
            var _x$invalidatesTags;

            if (typeof process !== 'undefined' && "development" === 'development') {
              console.warn('`invalidates` has been renamed to `invalidatesTags`, please change your code accordingly');
            }

            (_x$invalidatesTags = x.invalidatesTags) !== null && _x$invalidatesTags !== void 0 ? _x$invalidatesTags : x.invalidatesTags = x.invalidates;
          }

          return _objectSpread$3(_objectSpread$3({}, x), {}, {
            type: DefinitionType.mutation
          });
        }
      });

      for (var _i2 = 0, _Object$entries2 = Object.entries(evaluatedEndpoints); _i2 < _Object$entries2.length; _i2++) {
        var _Object$entries2$_i = _slicedToArray__default['default'](_Object$entries2[_i2], 2),
            endpointName = _Object$entries2$_i[0],
            definition = _Object$entries2$_i[1];

        if (typeof process !== 'undefined' && "development" === 'development') {
          if (!inject.overrideExisting && endpointName in context.endpointDefinitions) {
            console.error("called `injectEndpoints` to override already-existing endpointName ".concat(endpointName, " without specifying `overrideExisting: true`"));
            continue;
          }
        }

        context.endpointDefinitions[endpointName] = definition;

        var _iterator2 = _createForOfIteratorHelper$2(initializedModules),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var m = _step2.value;
            m.injectEndpoint(endpointName, definition);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }

      return api;
    }

    return api.injectEndpoints({
      endpoints: options.endpoints
    });
  };
}

/**
 * Creates a "fake" baseQuery to be used if your api *only* uses the `queryFn` definition syntax.
 * This also allows you to specify a specific error type to be shared by all your `queryFn` definitions.
 */


function fakeBaseQuery() {
  return function () {
    throw new Error('When using `fakeBaseQuery`, all queries & mutations must use the `queryFn` definition syntax.');
  };
}

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function defaultTransformResponse(baseQueryReturnValue) {
  return baseQueryReturnValue;
}

function buildThunks(_ref) {
  var reducerPath = _ref.reducerPath,
      baseQuery = _ref.baseQuery,
      endpointDefinitions = _ref.context.endpointDefinitions,
      serializeQueryArgs = _ref.serializeQueryArgs,
      api = _ref.api;

  var patchQueryResult = function patchQueryResult(endpointName, args, patches) {
    return function (dispatch) {
      var endpointDefinition = endpointDefinitions[endpointName];
      dispatch(api.internalActions.queryResultPatched({
        queryCacheKey: serializeQueryArgs({
          queryArgs: args,
          endpointDefinition: endpointDefinition,
          endpointName: endpointName
        }),
        patches: patches
      }));
    };
  };

  var updateQueryResult = function updateQueryResult(endpointName, args, updateRecipe) {
    return function (dispatch, getState) {
      var currentState = api.endpoints[endpointName].select(args)(getState());
      var ret = {
        patches: [],
        inversePatches: []
      };

      if (currentState.status === exports.QueryStatus.uninitialized) {
        return ret;
      }

      if ('data' in currentState) {
        if (immer.isDraftable(currentState.data)) {
          var _ret$patches, _ret$inversePatches;

          // call "enablePatches" as late as possible
          immer.enablePatches();

          var _produceWithPatches = immer.produceWithPatches(currentState.data, updateRecipe),
              _produceWithPatches2 = _slicedToArray__default['default'](_produceWithPatches, 3),
              patches = _produceWithPatches2[1],
              inversePatches = _produceWithPatches2[2];

          (_ret$patches = ret.patches).push.apply(_ret$patches, _toConsumableArray__default['default'](patches));

          (_ret$inversePatches = ret.inversePatches).push.apply(_ret$inversePatches, _toConsumableArray__default['default'](inversePatches));
        } else {
          var value = updateRecipe(currentState.data);
          ret.patches.push({
            op: 'replace',
            path: [],
            value: value
          });
          ret.inversePatches.push({
            op: 'replace',
            path: [],
            value: currentState.data
          });
        }
      }

      dispatch(patchQueryResult(endpointName, args, ret.patches));
      return ret;
    };
  };

  var executeEndpoint = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(arg, _ref2) {
      var signal, rejectWithValue, api, endpointDefinition, context, queryApi, transformResponse, result, baseQueryApi;
      return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              signal = _ref2.signal, rejectWithValue = _ref2.rejectWithValue, api = _objectWithoutProperties__default['default'](_ref2, ["signal", "rejectWithValue"]);
              endpointDefinition = endpointDefinitions[arg.endpointName];
              context = {};
              queryApi = _objectSpread$2(_objectSpread$2({}, api), {}, {
                context: context
              });
              if (endpointDefinition.onStart) endpointDefinition.onStart(arg.originalArgs, queryApi);
              _context.prev = 5;
              transformResponse = defaultTransformResponse;
              baseQueryApi = {
                signal: signal,
                dispatch: api.dispatch,
                getState: api.getState
              };

              if (!endpointDefinition.query) {
                _context.next = 15;
                break;
              }

              _context.next = 11;
              return baseQuery(endpointDefinition.query(arg.originalArgs), baseQueryApi, endpointDefinition.extraOptions);

            case 11:
              result = _context.sent;

              if (endpointDefinition.transformResponse) {
                transformResponse = endpointDefinition.transformResponse;
              }

              _context.next = 18;
              break;

            case 15:
              _context.next = 17;
              return endpointDefinition.queryFn(arg.originalArgs, baseQueryApi, endpointDefinition.extraOptions, function (arg) {
                return baseQuery(arg, baseQueryApi, endpointDefinition.extraOptions);
              });

            case 17:
              result = _context.sent;

            case 18:
              if (!result.error) {
                _context.next = 20;
                break;
              }

              throw new HandledError(result.error, result.meta);

            case 20:
              if (endpointDefinition.onSuccess) endpointDefinition.onSuccess(arg.originalArgs, queryApi, result.data, result.meta);
              _context.t0 = Date.now();
              _context.next = 24;
              return transformResponse(result.data, result.meta);

            case 24:
              _context.t1 = _context.sent;
              return _context.abrupt("return", {
                fulfilledTimeStamp: _context.t0,
                result: _context.t1
              });

            case 28:
              _context.prev = 28;
              _context.t2 = _context["catch"](5);
              if (endpointDefinition.onError) endpointDefinition.onError(arg.originalArgs, queryApi, _context.t2 instanceof HandledError ? _context.t2.value : _context.t2, _context.t2 instanceof HandledError ? _context.t2.meta : undefined);

              if (!(_context.t2 instanceof HandledError)) {
                _context.next = 33;
                break;
              }

              return _context.abrupt("return", rejectWithValue(_context.t2.value));

            case 33:
              throw _context.t2;

            case 34:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[5, 28]]);
    }));

    return function executeEndpoint(_x, _x2) {
      return _ref3.apply(this, arguments);
    };
  }();

  var queryThunk = toolkit.createAsyncThunk("".concat(reducerPath, "/executeQuery"), executeEndpoint, {
    condition: function condition(arg, _ref4) {
      var _state$queries, _arg$forceRefetch;

      var getState = _ref4.getState;
      var state = getState()[reducerPath];
      var requestState = state === null || state === void 0 ? void 0 : (_state$queries = state.queries) === null || _state$queries === void 0 ? void 0 : _state$queries[arg.queryCacheKey];
      var baseFetchOnMountOrArgChange = state.config.refetchOnMountOrArgChange;
      var fulfilledVal = requestState === null || requestState === void 0 ? void 0 : requestState.fulfilledTimeStamp;
      var refetchVal = (_arg$forceRefetch = arg.forceRefetch) !== null && _arg$forceRefetch !== void 0 ? _arg$forceRefetch : arg.subscribe && baseFetchOnMountOrArgChange; // Don't retry a request that's currently in-flight

      if ((requestState === null || requestState === void 0 ? void 0 : requestState.status) === 'pending') return false; // Pull from the cache unless we explicitly force refetch or qualify based on time

      if (fulfilledVal) {
        if (refetchVal) {
          // Return if its true or compare the dates because it must be a number
          return refetchVal === true || (Number(new Date()) - Number(fulfilledVal)) / 1000 >= refetchVal;
        } // Value is cached and we didn't specify to refresh, skip it.


        return false;
      }

      return true;
    },
    dispatchConditionRejection: true
  });
  var mutationThunk = toolkit.createAsyncThunk("".concat(reducerPath, "/executeMutation"), executeEndpoint);

  var hasTheForce = function hasTheForce(options) {
    return 'force' in options;
  };

  var hasMaxAge = function hasMaxAge(options) {
    return 'ifOlderThan' in options;
  };

  var prefetch = function prefetch(endpointName, arg, options) {
    return function (dispatch, getState) {
      var force = hasTheForce(options) && options.force;
      var maxAge = hasMaxAge(options) && options.ifOlderThan;

      var queryAction = function queryAction() {
        var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        return api.endpoints[endpointName].initiate(arg, {
          forceRefetch: force
        });
      };

      var latestStateValue = api.endpoints[endpointName].select(arg)(getState());

      if (force) {
        dispatch(queryAction());
      } else if (maxAge) {
        var lastFulfilledTs = latestStateValue === null || latestStateValue === void 0 ? void 0 : latestStateValue.fulfilledTimeStamp;

        if (!lastFulfilledTs) {
          dispatch(queryAction());
          return;
        }

        var shouldRetrigger = (Number(new Date()) - Number(new Date(lastFulfilledTs))) / 1000 >= maxAge;

        if (shouldRetrigger) {
          dispatch(queryAction());
        }
      } else {
        // If prefetching with no options, just let it try
        dispatch(queryAction(false));
      }
    };
  };

  function matchesEndpoint(endpointName) {
    return function (action) {
      var _action$meta, _action$meta$arg;

      return (action === null || action === void 0 ? void 0 : (_action$meta = action.meta) === null || _action$meta === void 0 ? void 0 : (_action$meta$arg = _action$meta.arg) === null || _action$meta$arg === void 0 ? void 0 : _action$meta$arg.endpointName) === endpointName;
    };
  }

  function buildMatchThunkActions(thunk, endpointName) {
    return {
      matchPending: toolkit.isAllOf(toolkit.isPending(thunk), matchesEndpoint(endpointName)),
      matchFulfilled: toolkit.isAllOf(toolkit.isFulfilled(thunk), matchesEndpoint(endpointName)),
      matchRejected: toolkit.isAllOf(toolkit.isRejected(thunk), matchesEndpoint(endpointName))
    };
  }

  return {
    queryThunk: queryThunk,
    mutationThunk: mutationThunk,
    prefetch: prefetch,
    updateQueryResult: updateQueryResult,
    patchQueryResult: patchQueryResult,
    buildMatchThunkActions: buildMatchThunkActions
  };
}
function calculateProvidedByThunk(action, type, endpointDefinitions, assertTagType) {
  return calculateProvidedBy(endpointDefinitions[action.meta.arg.endpointName][type], toolkit.isFulfilled(action) ? action.payload.result : undefined, toolkit.isRejectedWithValue(action) ? action.payload : undefined, action.meta.arg.originalArgs, assertTagType);
}

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createForOfIteratorHelper$1(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function updateQuerySubstateIfExists(state, queryCacheKey, update) {
  var substate = state[queryCacheKey];

  if (substate) {
    update(substate);
  }
}

function updateMutationSubstateIfExists(state, _ref, update) {
  var requestId = _ref.requestId;
  var substate = state[requestId];

  if (substate) {
    update(substate);
  }
}

var initialState = {};
function buildSlice(_ref2) {
  var reducerPath = _ref2.reducerPath,
      queryThunk = _ref2.queryThunk,
      mutationThunk = _ref2.mutationThunk,
      definitions = _ref2.context.endpointDefinitions,
      assertTagType = _ref2.assertTagType,
      config = _ref2.config;
  var resetApiState = toolkit.createAction("".concat(reducerPath, "/resetApiState"));
  var querySlice = toolkit.createSlice({
    name: "".concat(reducerPath, "/queries"),
    initialState: initialState,
    reducers: {
      removeQueryResult: function removeQueryResult(draft, _ref3) {
        var queryCacheKey = _ref3.payload.queryCacheKey;
        delete draft[queryCacheKey];
      },
      queryResultPatched: function queryResultPatched(draft, _ref4) {
        var _ref4$payload = _ref4.payload,
            queryCacheKey = _ref4$payload.queryCacheKey,
            patches = _ref4$payload.patches;
        updateQuerySubstateIfExists(draft, queryCacheKey, function (substate) {
          substate.data = immer.applyPatches(substate.data, patches);
        });
      }
    },
    extraReducers: function extraReducers(builder) {
      builder.addCase(queryThunk.pending, function (draft, _ref5) {
        var _ref5$meta = _ref5.meta,
            arg = _ref5$meta.arg,
            requestId = _ref5$meta.requestId;

        if (arg.subscribe) {
          var _arg$queryCacheKey, _draft$_arg$queryCach;

          // only initialize substate if we want to subscribe to it
          (_draft$_arg$queryCach = draft[_arg$queryCacheKey = arg.queryCacheKey]) !== null && _draft$_arg$queryCach !== void 0 ? _draft$_arg$queryCach : draft[_arg$queryCacheKey] = {
            status: exports.QueryStatus.uninitialized,
            endpointName: arg.endpointName
          };
        }

        updateQuerySubstateIfExists(draft, arg.queryCacheKey, function (substate) {
          substate.status = exports.QueryStatus.pending;
          substate.requestId = requestId;
          substate.originalArgs = arg.originalArgs;
          substate.startedTimeStamp = arg.startedTimeStamp;
        });
      }).addCase(queryThunk.fulfilled, function (draft, _ref6) {
        var meta = _ref6.meta,
            payload = _ref6.payload;
        updateQuerySubstateIfExists(draft, meta.arg.queryCacheKey, function (substate) {
          if (substate.requestId !== meta.requestId) return;
          substate.status = exports.QueryStatus.fulfilled;
          substate.data = copyWithStructuralSharing(substate.data, payload.result);
          delete substate.error;
          substate.fulfilledTimeStamp = payload.fulfilledTimeStamp;
        });
      }).addCase(queryThunk.rejected, function (draft, _ref7) {
        var _ref7$meta = _ref7.meta,
            condition = _ref7$meta.condition,
            arg = _ref7$meta.arg,
            requestId = _ref7$meta.requestId,
            error = _ref7.error,
            payload = _ref7.payload;
        updateQuerySubstateIfExists(draft, arg.queryCacheKey, function (substate) {
          if (condition) ; else {
            // request failed
            if (substate.requestId !== requestId) return;
            substate.status = exports.QueryStatus.rejected;
            substate.error = payload !== null && payload !== void 0 ? payload : error;
          }
        });
      });
    }
  });
  var mutationSlice = toolkit.createSlice({
    name: "".concat(reducerPath, "/mutations"),
    initialState: initialState,
    reducers: {
      unsubscribeResult: function unsubscribeResult(draft, action) {
        if (action.payload.requestId in draft) {
          delete draft[action.payload.requestId];
        }
      }
    },
    extraReducers: function extraReducers(builder) {
      builder.addCase(mutationThunk.pending, function (draft, _ref8) {
        var _ref8$meta = _ref8.meta,
            arg = _ref8$meta.arg,
            requestId = _ref8$meta.requestId;
        if (!arg.track) return;
        draft[requestId] = {
          status: exports.QueryStatus.pending,
          originalArgs: arg.originalArgs,
          endpointName: arg.endpointName,
          startedTimeStamp: arg.startedTimeStamp
        };
      }).addCase(mutationThunk.fulfilled, function (draft, _ref9) {
        var payload = _ref9.payload,
            _ref9$meta = _ref9.meta,
            requestId = _ref9$meta.requestId,
            arg = _ref9$meta.arg;
        if (!arg.track) return;
        updateMutationSubstateIfExists(draft, {
          requestId: requestId
        }, function (substate) {
          substate.status = exports.QueryStatus.fulfilled;
          substate.data = payload.result;
          substate.fulfilledTimeStamp = payload.fulfilledTimeStamp;
        });
      }).addCase(mutationThunk.rejected, function (draft, _ref10) {
        var payload = _ref10.payload,
            error = _ref10.error,
            _ref10$meta = _ref10.meta,
            requestId = _ref10$meta.requestId,
            arg = _ref10$meta.arg;
        if (!arg.track) return;
        updateMutationSubstateIfExists(draft, {
          requestId: requestId
        }, function (substate) {
          substate.status = exports.QueryStatus.rejected;
          substate.error = payload !== null && payload !== void 0 ? payload : error;
        });
      });
    }
  });
  var invalidationSlice = toolkit.createSlice({
    name: "".concat(reducerPath, "/invalidation"),
    initialState: initialState,
    reducers: {},
    extraReducers: function extraReducers(builder) {
      builder.addCase(querySlice.actions.removeQueryResult, function (draft, _ref11) {
        var queryCacheKey = _ref11.payload.queryCacheKey;

        for (var _i = 0, _Object$values = Object.values(draft); _i < _Object$values.length; _i++) {
          var tagTypeSubscriptions = _Object$values[_i];

          for (var _i2 = 0, _Object$values2 = Object.values(tagTypeSubscriptions); _i2 < _Object$values2.length; _i2++) {
            var idSubscriptions = _Object$values2[_i2];
            var foundAt = idSubscriptions.indexOf(queryCacheKey);

            if (foundAt !== -1) {
              idSubscriptions.splice(foundAt, 1);
            }
          }
        }
      }).addMatcher(toolkit.isAnyOf(toolkit.isFulfilled(queryThunk), toolkit.isRejectedWithValue(queryThunk)), function (draft, action) {
        var providedTags = calculateProvidedByThunk(action, 'providesTags', definitions, assertTagType);
        var queryCacheKey = action.meta.arg.queryCacheKey;

        var _iterator = _createForOfIteratorHelper$1(providedTags),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _draft$type, _ref12, _draft$type$_ref, _draft$type2;

            var _step$value = _step.value,
                type = _step$value.type,
                id = _step$value.id;
            var subscribedQueries = (_draft$type$_ref = (_draft$type = (_draft$type2 = draft[type]) !== null && _draft$type2 !== void 0 ? _draft$type2 : draft[type] = {})[_ref12 = id || '__internal_without_id']) !== null && _draft$type$_ref !== void 0 ? _draft$type$_ref : _draft$type[_ref12] = [];
            var alreadySubscribed = subscribedQueries.includes(queryCacheKey);

            if (!alreadySubscribed) {
              subscribedQueries.push(queryCacheKey);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      });
    }
  });
  var subscriptionSlice = toolkit.createSlice({
    name: "".concat(reducerPath, "/subscriptions"),
    initialState: initialState,
    reducers: {
      updateSubscriptionOptions: function updateSubscriptionOptions(draft, _ref13) {
        var _draft$queryCacheKey;

        var _ref13$payload = _ref13.payload,
            queryCacheKey = _ref13$payload.queryCacheKey,
            requestId = _ref13$payload.requestId,
            options = _ref13$payload.options;

        if (draft !== null && draft !== void 0 && (_draft$queryCacheKey = draft[queryCacheKey]) !== null && _draft$queryCacheKey !== void 0 && _draft$queryCacheKey[requestId]) {
          draft[queryCacheKey][requestId] = options;
        }
      },
      unsubscribeResult: function unsubscribeResult(draft, _ref14) {
        var _ref14$payload = _ref14.payload,
            queryCacheKey = _ref14$payload.queryCacheKey,
            requestId = _ref14$payload.requestId;

        if (draft[queryCacheKey]) {
          delete draft[queryCacheKey][requestId];
        }
      }
    },
    extraReducers: function extraReducers(builder) {
      builder.addCase(querySlice.actions.removeQueryResult, function (draft, _ref15) {
        var queryCacheKey = _ref15.payload.queryCacheKey;
        delete draft[queryCacheKey];
      }).addCase(queryThunk.pending, function (draft, _ref16) {
        var _ref16$meta = _ref16.meta,
            arg = _ref16$meta.arg,
            requestId = _ref16$meta.requestId;

        if (arg.subscribe) {
          var _arg$queryCacheKey2, _draft$_arg$queryCach2, _ref17, _arg$subscriptionOpti;

          var substate = (_draft$_arg$queryCach2 = draft[_arg$queryCacheKey2 = arg.queryCacheKey]) !== null && _draft$_arg$queryCach2 !== void 0 ? _draft$_arg$queryCach2 : draft[_arg$queryCacheKey2] = {};
          substate[requestId] = (_ref17 = (_arg$subscriptionOpti = arg.subscriptionOptions) !== null && _arg$subscriptionOpti !== void 0 ? _arg$subscriptionOpti : substate[requestId]) !== null && _ref17 !== void 0 ? _ref17 : {};
        }
      }).addCase(queryThunk.rejected, function (draft, _ref18) {
        var _ref18$meta = _ref18.meta,
            condition = _ref18$meta.condition,
            arg = _ref18$meta.arg,
            requestId = _ref18$meta.requestId;
        var substate = draft[arg.queryCacheKey]; // request was aborted due to condition (another query already running)

        if (condition && arg.subscribe && substate) {
          var _ref19, _arg$subscriptionOpti2;

          substate[requestId] = (_ref19 = (_arg$subscriptionOpti2 = arg.subscriptionOptions) !== null && _arg$subscriptionOpti2 !== void 0 ? _arg$subscriptionOpti2 : substate[requestId]) !== null && _ref19 !== void 0 ? _ref19 : {};
        }
      });
    }
  });
  var configSlice = toolkit.createSlice({
    name: "".concat(reducerPath, "/config"),
    initialState: _objectSpread$1({
      online: isOnline(),
      focused: isDocumentVisible()
    }, config),
    reducers: {},
    extraReducers: function extraReducers(builder) {
      builder.addCase(onOnline, function (state) {
        state.online = true;
      }).addCase(onOffline, function (state) {
        state.online = false;
      }).addCase(onFocus, function (state) {
        state.focused = true;
      }).addCase(onFocusLost, function (state) {
        state.focused = false;
      });
    }
  });
  var combinedReducer = toolkit.combineReducers({
    queries: querySlice.reducer,
    mutations: mutationSlice.reducer,
    provided: invalidationSlice.reducer,
    subscriptions: subscriptionSlice.reducer,
    config: configSlice.reducer
  });

  var reducer = function reducer(state, action) {
    return combinedReducer(resetApiState.match(action) ? undefined : state, action);
  };

  var actions = {
    updateSubscriptionOptions: subscriptionSlice.actions.updateSubscriptionOptions,
    queryResultPatched: querySlice.actions.queryResultPatched,
    removeQueryResult: querySlice.actions.removeQueryResult,
    unsubscribeQueryResult: subscriptionSlice.actions.unsubscribeResult,
    unsubscribeMutationResult: mutationSlice.actions.unsubscribeResult,
    resetApiState: resetApiState
  };
  return {
    reducer: reducer,
    actions: actions
  };
}

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
function buildMiddleware(_ref) {
  var reducerPath = _ref.reducerPath,
      context = _ref.context,
      endpointDefinitions = _ref.context.endpointDefinitions,
      queryThunk = _ref.queryThunk,
      mutationThunk = _ref.mutationThunk,
      api = _ref.api,
      assertTagType = _ref.assertTagType;
  var _api$internalActions = api.internalActions,
      removeQueryResult = _api$internalActions.removeQueryResult,
      unsubscribeQueryResult = _api$internalActions.unsubscribeQueryResult,
      updateSubscriptionOptions = _api$internalActions.updateSubscriptionOptions,
      resetApiState = _api$internalActions.resetApiState;
  var currentRemovalTimeouts = {};
  var currentPolls = {};
  var actions = {
    invalidateTags: toolkit.createAction("".concat(reducerPath, "/invalidateTags"))
  };

  var middleware = function middleware(mwApi) {
    return function (next) {
      return function (action) {
        var result = next(action);

        if (toolkit.isAnyOf(toolkit.isFulfilled(mutationThunk), toolkit.isRejectedWithValue(mutationThunk))(action)) {
          invalidateTags(calculateProvidedByThunk(action, 'invalidatesTags', endpointDefinitions, assertTagType), mwApi);
        }

        if (actions.invalidateTags.match(action)) {
          invalidateTags(calculateProvidedBy(action.payload, undefined, undefined, undefined, assertTagType), mwApi);
        }

        if (unsubscribeQueryResult.match(action)) {
          handleUnsubscribe(action.payload, mwApi);
        }

        if (updateSubscriptionOptions.match(action)) {
          updatePollingInterval(action.payload, mwApi);
        }

        if (queryThunk.pending.match(action) || queryThunk.rejected.match(action) && action.meta.condition) {
          updatePollingInterval(action.meta.arg, mwApi);
        }

        if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action) && !action.meta.condition) {
          startNextPoll(action.meta.arg, mwApi);
        }

        if (onFocus.match(action)) {
          refetchValidQueries(mwApi, 'refetchOnFocus');
        }

        if (onOnline.match(action)) {
          refetchValidQueries(mwApi, 'refetchOnReconnect');
        }

        if (resetApiState.match(action)) {
          for (var _i = 0, _Object$entries = Object.entries(currentPolls); _i < _Object$entries.length; _i++) {
            var _Object$entries$_i = _slicedToArray__default['default'](_Object$entries[_i], 2),
                key = _Object$entries$_i[0],
                poll = _Object$entries$_i[1];

            if (poll !== null && poll !== void 0 && poll.timeout) clearTimeout(poll.timeout);
            delete currentPolls[key];
          }

          for (var _i2 = 0, _Object$entries2 = Object.entries(currentRemovalTimeouts); _i2 < _Object$entries2.length; _i2++) {
            var _Object$entries2$_i = _slicedToArray__default['default'](_Object$entries2[_i2], 2),
                _key = _Object$entries2$_i[0],
                timeout = _Object$entries2$_i[1];

            if (timeout) clearTimeout(timeout);
            delete currentRemovalTimeouts[_key];
          }
        }

        return result;
      };
    };
  };

  return {
    middleware: middleware,
    actions: actions
  };

  function refetchQuery(querySubState, queryCacheKey) {
    var override = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return queryThunk(_objectSpread({
      endpointName: querySubState.endpointName,
      originalArgs: querySubState.originalArgs,
      subscribe: false,
      forceRefetch: true,
      startedTimeStamp: Date.now(),
      queryCacheKey: queryCacheKey
    }, override));
  }

  function refetchValidQueries(api, type) {
    var state = api.getState()[reducerPath];
    var queries = state.queries;
    var subscriptions = state.subscriptions;
    context.batch(function () {
      for (var _i3 = 0, _Object$keys = Object.keys(subscriptions); _i3 < _Object$keys.length; _i3++) {
        var queryCacheKey = _Object$keys[_i3];
        var querySubState = queries[queryCacheKey];
        var subscriptionSubState = subscriptions[queryCacheKey];
        if (!subscriptionSubState || !querySubState || querySubState.status === exports.QueryStatus.uninitialized) return;
        var shouldRefetch = Object.values(subscriptionSubState).some(function (sub) {
          return sub[type] === true;
        }) || Object.values(subscriptionSubState).every(function (sub) {
          return sub[type] === undefined;
        }) && state.config[type];

        if (shouldRefetch) {
          api.dispatch(refetchQuery(querySubState, queryCacheKey));
        }
      }
    });
  }

  function invalidateTags(tags, api) {
    var state = api.getState()[reducerPath];
    var toInvalidate = new Set();

    var _iterator = _createForOfIteratorHelper(tags),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _ref2;

        var tag = _step.value;
        var provided = state.provided[tag.type];

        if (!provided) {
          continue;
        }

        var invalidateSubscriptions = (_ref2 = tag.id !== undefined ? // id given: invalidate all queries that provide this type & id
        provided[tag.id] : // no id: invalidate all queries that provide this type
        flatten(Object.values(provided))) !== null && _ref2 !== void 0 ? _ref2 : [];

        var _iterator3 = _createForOfIteratorHelper(invalidateSubscriptions),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var invalidate = _step3.value;
            toInvalidate.add(invalidate);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    context.batch(function () {
      var _iterator2 = _createForOfIteratorHelper(toInvalidate.values()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var queryCacheKey = _step2.value;
          var querySubState = state.queries[queryCacheKey];
          var subscriptionSubState = state.subscriptions[queryCacheKey];

          if (querySubState && subscriptionSubState) {
            if (Object.keys(subscriptionSubState).length === 0) {
              api.dispatch(removeQueryResult({
                queryCacheKey: queryCacheKey
              }));
            } else if (querySubState.status !== exports.QueryStatus.uninitialized) {
              api.dispatch(refetchQuery(querySubState, queryCacheKey));
            } else {}
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    });
  }

  function handleUnsubscribe(_ref3, api) {
    var queryCacheKey = _ref3.queryCacheKey;
    var keepUnusedDataFor = api.getState()[reducerPath].config.keepUnusedDataFor;
    var currentTimeout = currentRemovalTimeouts[queryCacheKey];

    if (currentTimeout) {
      clearTimeout(currentTimeout);
    }

    currentRemovalTimeouts[queryCacheKey] = setTimeout(function () {
      var subscriptions = api.getState()[reducerPath].subscriptions[queryCacheKey];

      if (!subscriptions || Object.keys(subscriptions).length === 0) {
        api.dispatch(removeQueryResult({
          queryCacheKey: queryCacheKey
        }));
      }

      delete currentRemovalTimeouts[queryCacheKey];
    }, keepUnusedDataFor * 1000);
  }

  function startNextPoll(_ref4, api) {
    var queryCacheKey = _ref4.queryCacheKey;
    var state = api.getState()[reducerPath];
    var querySubState = state.queries[queryCacheKey];
    var subscriptions = state.subscriptions[queryCacheKey];
    if (!querySubState || querySubState.status === exports.QueryStatus.uninitialized) return;
    var lowestPollingInterval = findLowestPollingInterval(subscriptions);
    if (!Number.isFinite(lowestPollingInterval)) return;
    var currentPoll = currentPolls[queryCacheKey];

    if (currentPoll !== null && currentPoll !== void 0 && currentPoll.timeout) {
      clearTimeout(currentPoll.timeout);
      currentPoll.timeout = undefined;
    }

    var nextPollTimestamp = Date.now() + lowestPollingInterval;
    var currentInterval = currentPolls[queryCacheKey] = {
      nextPollTimestamp: nextPollTimestamp,
      pollingInterval: lowestPollingInterval,
      timeout: setTimeout(function () {
        currentInterval.timeout = undefined;
        api.dispatch(refetchQuery(querySubState, queryCacheKey));
      }, lowestPollingInterval)
    };
  }

  function updatePollingInterval(_ref5, api) {
    var queryCacheKey = _ref5.queryCacheKey;
    var state = api.getState()[reducerPath];
    var querySubState = state.queries[queryCacheKey];
    var subscriptions = state.subscriptions[queryCacheKey];

    if (!querySubState || querySubState.status === exports.QueryStatus.uninitialized) {
      return;
    }

    var lowestPollingInterval = findLowestPollingInterval(subscriptions);
    var currentPoll = currentPolls[queryCacheKey];

    if (!Number.isFinite(lowestPollingInterval)) {
      if (currentPoll !== null && currentPoll !== void 0 && currentPoll.timeout) {
        clearTimeout(currentPoll.timeout);
      }

      delete currentPolls[queryCacheKey];
      return;
    }

    var nextPollTimestamp = Date.now() + lowestPollingInterval;

    if (!currentPoll || nextPollTimestamp < currentPoll.nextPollTimestamp) {
      startNextPoll({
        queryCacheKey: queryCacheKey
      }, api);
    }
  }
}

function findLowestPollingInterval() {
  var subscribers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var lowestPollingInterval = Number.POSITIVE_INFINITY;

  for (var _i4 = 0, _Object$values = Object.values(subscribers); _i4 < _Object$values.length; _i4++) {
    var subscription = _Object$values[_i4];
    if (!!subscription.pollingInterval) lowestPollingInterval = Math.min(subscription.pollingInterval, lowestPollingInterval);
  }

  return lowestPollingInterval;
}

function buildInitiate(_ref) {
  var serializeQueryArgs = _ref.serializeQueryArgs,
      queryThunk = _ref.queryThunk,
      mutationThunk = _ref.mutationThunk,
      api = _ref.api;
  var _api$internalActions = api.internalActions,
      unsubscribeQueryResult = _api$internalActions.unsubscribeQueryResult,
      unsubscribeMutationResult = _api$internalActions.unsubscribeMutationResult,
      _updateSubscriptionOptions = _api$internalActions.updateSubscriptionOptions;
  return {
    buildInitiateQuery: buildInitiateQuery,
    buildInitiateMutation: buildInitiateMutation
  };

  function buildInitiateQuery(endpointName, endpointDefinition) {
    var queryAction = function queryAction(arg) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$subscribe = _ref2.subscribe,
          subscribe = _ref2$subscribe === void 0 ? true : _ref2$subscribe,
          forceRefetch = _ref2.forceRefetch,
          subscriptionOptions = _ref2.subscriptionOptions;

      return function (dispatch, getState) {
        var queryCacheKey = serializeQueryArgs({
          queryArgs: arg,
          endpointDefinition: endpointDefinition,
          endpointName: endpointName
        });
        var thunk = queryThunk({
          subscribe: subscribe,
          forceRefetch: forceRefetch,
          subscriptionOptions: subscriptionOptions,
          endpointName: endpointName,
          originalArgs: arg,
          queryCacheKey: queryCacheKey,
          startedTimeStamp: Date.now()
        });
        var thunkResult = dispatch(thunk);
        var requestId = thunkResult.requestId,
            abort = thunkResult.abort;
        var statePromise = Object.assign(thunkResult.then(function () {
          return api.endpoints[endpointName].select(arg)(getState());
        }), {
          arg: arg,
          requestId: requestId,
          subscriptionOptions: subscriptionOptions,
          abort: abort,
          refetch: function refetch() {
            dispatch(queryAction(arg, {
              subscribe: false,
              forceRefetch: true
            }));
          },
          unsubscribe: function unsubscribe() {
            if (subscribe) dispatch(unsubscribeQueryResult({
              queryCacheKey: queryCacheKey,
              requestId: requestId
            }));
          },
          updateSubscriptionOptions: function updateSubscriptionOptions(options) {
            statePromise.subscriptionOptions = options;
            dispatch(_updateSubscriptionOptions({
              endpointName: endpointName,
              requestId: requestId,
              queryCacheKey: queryCacheKey,
              options: options
            }));
          }
        });
        return statePromise;
      };
    };

    return queryAction;
  }

  function buildInitiateMutation(endpointName, definition) {
    return function (arg) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref3$track = _ref3.track,
          track = _ref3$track === void 0 ? true : _ref3$track;

      return function (dispatch, getState) {
        var thunk = mutationThunk({
          endpointName: endpointName,
          originalArgs: arg,
          track: track,
          startedTimeStamp: Date.now()
        });
        var thunkResult = dispatch(thunk);
        var requestId = thunkResult.requestId,
            abort = thunkResult.abort;
        var returnValuePromise = thunkResult.then(toolkit.unwrapResult).then(function (unwrapped) {
          return {
            data: unwrapped.result
          };
        }).catch(function (error) {
          return {
            error: error
          };
        });
        return Object.assign(returnValuePromise, {
          arg: thunkResult.arg,
          requestId: requestId,
          abort: abort,
          unwrap: function unwrap() {
            return thunkResult.then(toolkit.unwrapResult).then(function (unwrapped) {
              return unwrapped.result;
            });
          },
          unsubscribe: function unsubscribe() {
            if (track) dispatch(unsubscribeMutationResult({
              requestId: requestId
            }));
          }
        });
      };
    };
  }
}

function safeAssign(target) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  Object.assign.apply(Object, [target].concat(args));
}

/**
 * Note: this file should import all other files for type discovery and declaration merging
 */
var coreModuleName = Symbol();
/**
 * Creates a module containing the basic redux logic for use with `buildCreateApi`.
 *
 * @example
 * ```ts
 * const createBaseApi = buildCreateApi(coreModule());
 * ```
 */

var coreModule = function coreModule() {
  return {
    name: coreModuleName,
    init: function init(api, _ref, context) {
      var baseQuery = _ref.baseQuery,
          tagTypes = _ref.tagTypes,
          reducerPath = _ref.reducerPath,
          serializeQueryArgs = _ref.serializeQueryArgs,
          keepUnusedDataFor = _ref.keepUnusedDataFor,
          refetchOnMountOrArgChange = _ref.refetchOnMountOrArgChange,
          refetchOnFocus = _ref.refetchOnFocus,
          refetchOnReconnect = _ref.refetchOnReconnect;

      var assertTagType = function assertTagType(tag) {
        if (typeof process !== 'undefined' && "development" === 'development') {
          if (!tagTypes.includes(tag.type)) {
            console.error("Tag type '".concat(tag.type, "' was used, but not specified in `tagTypes`!"));
          }
        }

        return tag;
      };

      Object.assign(api, {
        reducerPath: reducerPath,
        endpoints: {},
        internalActions: {
          onOnline: onOnline,
          onOffline: onOffline,
          onFocus: onFocus,
          onFocusLost: onFocusLost
        },
        util: {}
      });

      var _buildThunks = buildThunks({
        baseQuery: baseQuery,
        reducerPath: reducerPath,
        context: context,
        api: api,
        serializeQueryArgs: serializeQueryArgs
      }),
          queryThunk = _buildThunks.queryThunk,
          mutationThunk = _buildThunks.mutationThunk,
          patchQueryResult = _buildThunks.patchQueryResult,
          updateQueryResult = _buildThunks.updateQueryResult,
          prefetch = _buildThunks.prefetch,
          buildMatchThunkActions = _buildThunks.buildMatchThunkActions;

      var _buildSlice = buildSlice({
        context: context,
        queryThunk: queryThunk,
        mutationThunk: mutationThunk,
        reducerPath: reducerPath,
        assertTagType: assertTagType,
        config: {
          refetchOnFocus: refetchOnFocus,
          refetchOnReconnect: refetchOnReconnect,
          refetchOnMountOrArgChange: refetchOnMountOrArgChange,
          keepUnusedDataFor: keepUnusedDataFor,
          reducerPath: reducerPath
        }
      }),
          reducer = _buildSlice.reducer,
          sliceActions = _buildSlice.actions;

      safeAssign(api.util, {
        patchQueryResult: patchQueryResult,
        updateQueryResult: updateQueryResult,
        prefetch: prefetch,
        resetApiState: sliceActions.resetApiState
      });
      safeAssign(api.internalActions, sliceActions);

      var _buildMiddleware = buildMiddleware({
        reducerPath: reducerPath,
        context: context,
        queryThunk: queryThunk,
        mutationThunk: mutationThunk,
        api: api,
        assertTagType: assertTagType
      }),
          middleware = _buildMiddleware.middleware,
          middlewareActions = _buildMiddleware.actions;

      safeAssign(api.util, middlewareActions);
      safeAssign(api, {
        reducer: reducer,
        middleware: middleware
      });

      var _buildSelectors = buildSelectors({
        serializeQueryArgs: serializeQueryArgs,
        reducerPath: reducerPath
      }),
          buildQuerySelector = _buildSelectors.buildQuerySelector,
          buildMutationSelector = _buildSelectors.buildMutationSelector;

      var _buildInitiate = buildInitiate({
        queryThunk: queryThunk,
        mutationThunk: mutationThunk,
        api: api,
        serializeQueryArgs: serializeQueryArgs
      }),
          buildInitiateQuery = _buildInitiate.buildInitiateQuery,
          buildInitiateMutation = _buildInitiate.buildInitiateMutation; // remove in final release


      Object.defineProperty(api.util, 'invalidateEntities', {
        get: function get() {
          if (typeof process !== 'undefined' && "development" === 'development') {
            console.warn('`api.util.invalidateEntities` has been renamed to `api.util.invalidateTags`, please change your code accordingly');
          }

          return api.util.invalidateTags;
        }
      });
      Object.defineProperty(api.util, 'prefetchThunk', {
        get: function get() {
          if (typeof process !== 'undefined' && "development" === 'development') {
            console.warn('`api.util.prefetchThunk` has been renamed to `api.util.prefetch`, please change your code accordingly');
          }

          return api.util.prefetch;
        }
      });
      return {
        name: coreModuleName,
        injectEndpoint: function injectEndpoint(endpointName, definition) {
          var _anyApi$endpoints, _anyApi$endpoints$end;

          var anyApi = api;
          (_anyApi$endpoints$end = (_anyApi$endpoints = anyApi.endpoints)[endpointName]) !== null && _anyApi$endpoints$end !== void 0 ? _anyApi$endpoints$end : _anyApi$endpoints[endpointName] = {};

          if (isQueryDefinition(definition)) {
            safeAssign(anyApi.endpoints[endpointName], {
              select: buildQuerySelector(endpointName, definition),
              initiate: buildInitiateQuery(endpointName, definition)
            }, buildMatchThunkActions(queryThunk, endpointName));
          } else if (isMutationDefinition(definition)) {
            safeAssign(anyApi.endpoints[endpointName], {
              select: buildMutationSelector(),
              initiate: buildInitiateMutation(endpointName, definition)
            }, buildMatchThunkActions(mutationThunk, endpointName));
          }
        }
      };
    }
  };
};

var createApi = buildCreateApi(coreModule());

exports.buildCreateApi = buildCreateApi;
exports.coreModule = coreModule;
exports.createApi = createApi;
exports.fakeBaseQuery = fakeBaseQuery;
exports.fetchBaseQuery = fetchBaseQuery;
exports.retry = retry;
exports.setupListeners = setupListeners;
exports.skipSelector = skipSelector;
//# sourceMappingURL=index.cjs.development.js.map
